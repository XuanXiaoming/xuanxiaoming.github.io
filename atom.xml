<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ming&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuanxiaoming.github.io/"/>
  <updated>2023-04-27T09:08:26.095Z</updated>
  <id>https://xuanxiaoming.github.io/</id>
  
  <author>
    <name>ming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL主从同步原理</title>
    <link href="https://xuanxiaoming.github.io/2023/01/17/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/"/>
    <id>https://xuanxiaoming.github.io/2023/01/17/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</id>
    <published>2023-01-17T08:59:26.000Z</published>
    <updated>2023-04-27T09:08:26.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是MySQL主从同步"><a href="#什么是MySQL主从同步" class="headerlink" title="什么是MySQL主从同步"></a>什么是MySQL主从同步</h1><p>当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。</p><h1 id="主从同步有什么好处"><a href="#主从同步有什么好处" class="headerlink" title="主从同步有什么好处"></a>主从同步有什么好处</h1><ul><li><p>水平扩展数据库的负载能力。</p></li><li><p>容错，高可用。Failover(失败切换)/High Availability</p></li><li><p>数据备份。</p></li></ul><h1 id="主从同步的原理"><a href="#主从同步的原理" class="headerlink" title="主从同步的原理"></a>主从同步的原理</h1><p>不管是delete、update、insert，还是创建函数、存储过程，所有的操作都在master上。当master有操作的时候，slave会快速的接收到这些操作，从而做同步。</p><p>在master机器上，主从同步事件会被写到特殊的log文件中（binary-log），然后slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。</p><p>主从同步事件有3种形式：statement、row、mixed。</p><ol><li><p>statement：对数据库操作的sql语句写入到binlog中。</p></li><li><p>row：将每一条数据的变化写入到binlog中。</p></li><li><p>mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。</p></li></ol><h2 id="在master机器上的操作"><a href="#在master机器上的操作" class="headerlink" title="在master机器上的操作"></a>在master机器上的操作</h2><p>当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。</p><p>当slave连接到master的时候，master机器会为slave开启binlog dump线程。当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。</p><h2 id="在slave机器上的操作"><a href="#在slave机器上的操作" class="headerlink" title="在slave机器上的操作"></a>在slave机器上的操作</h2><p>当主从同步开启的时候，slave上会创建2个线程。</p><ul><li><p>I/O线程</p><p>该线程连接到master机器，master机器上的binlog dump线程会将binlog的内容发送给该I/O线程。</p><p>该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。</p></li><li><p>SQL线程</p><p>该线程读取I/O线程写入的relay log。并且根据relay log的内容对slave数据库做相应的操作。</p></li></ul><h2 id="在master、slave上查看上述线程"><a href="#在master、slave上查看上述线程" class="headerlink" title="在master、slave上查看上述线程"></a><strong>在master、slave上查看上述线程</strong></h2><p>使用SHOW PROCESSLIST命令可以查看。在master机器上查看binlog dump线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是MySQL主从同步&quot;&gt;&lt;a href=&quot;#什么是MySQL主从同步&quot; class=&quot;headerlink&quot; title=&quot;什么是MySQL主从同步&quot;&gt;&lt;/a&gt;什么是MySQL主从同步&lt;/h1&gt;&lt;p&gt;当master(主)库的数据发生变化的时候，变化会实时的同步
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL语法整理</title>
    <link href="https://xuanxiaoming.github.io/2023/01/02/sql%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://xuanxiaoming.github.io/2023/01/02/sql%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2023-01-02T08:35:46.000Z</published>
    <updated>2023-04-27T09:08:14.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><pre class="line-numbers language-SQL"><code class="language-SQL">// 增INSERT INTO 表名称 VALUES (值1, 值2,....)INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)// 删DELETE FROM 表名称 WHERE 列名称 = 值// 改UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值// 查SELECT 列名称 FROM 表名称SELECT * FROM 表名称// 查找去重（使用DISTINCT）SELECT DISTINCT 列名称 FROM 表名称// 查找增加筛选条件（逻辑子句可以使用AND或OR结合多条子句）SELECT 列名称 FROM 表名称 WHERE 逻辑子句// 查找结果集排序（结尾用ASC或DESC选择正序排还是逆序排）SELECT 列名称 FROM 表名称 ORDER BY 列名称 [ASC DESC]// 查找结果集分组SELECT 列名称 FROM 表名称 GROUP BY 列名称// 查找结果集分组后，按条件筛选SELECT 列名称 FROM 表名称 GROUP BY 列名称 HAVING 条件// 查找符合范围内的数据（判断范围包含LOW和HIGH的边界值）SELECT 列名称 FROM 表名称 WHERE 条件数据列名 BETWEEN LOW AND HIGH;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><ul><li><p><strong>now()</strong></p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select now();  +---------------------+  | now()               |  +---------------------+  | 2023-02-16 18:31:56 |  +---------------------+  1 row in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>sysdate()</strong></p><p>sysdate()日期时间函数跟now()一样获取系统时间，不同之处在于：now()在执行开始时值就得到了， sysdate()在函数执行时动态得到值。</p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select now(),sleep(2),sysdate(),now();  +---------------------+----------+---------------------+---------------------+  | now()               | sleep(2) | sysdate()           | now()               |  +---------------------+----------+---------------------+---------------------+  | 2023-02-16 18:37:53 |        0 | 2023-02-16 18:37:55 | 2023-02-16 18:37:53 |  +---------------------+----------+---------------------+---------------------+  1 row in set (2.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>current_timestamp</strong></p><p><strong>DEFAULT CURRENT_TIMESTAMP</strong> 表示当插入数据的时候，该字段默认值为当前时间</p><p><strong>ON UPDATE CURRENT_TIMESTAMP</strong> 表示每次更新这条数据的时候，该字段都会更新成当前时间</p><p>这两个操作是mysql数据库本身在维护，所以可以根据这个特性来生成【创建时间】和【更新时间】两个字段，且不需要代码来维护</p><pre class="line-numbers language-SQL"><code class="language-SQL">  CREATE TABLE `test` (      `text` varchar(255) DEFAULT '' COMMENT '内容',      `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',      `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>date_format(date,format)、time_format(time,format) 日期、时间转字符串函数，str_to_date(str, format) 字符串转日期函数</strong></p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select date_format(now(), '%Y%m%d %H:%i:%s');  +---------------------------------------+  | date_format(now(), '%Y%m%d %H:%i:%s') |  +---------------------------------------+  | 20230217 03:56:33                     |  +---------------------------------------+  1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre><code># str_to_date() 在使用时format中使用的分隔符要与字符串使用的分隔符匹配mysql&gt; select str_to_date(&#39;2022-12-12&#39;, &#39;%Y-%m-%d&#39;);+---------------------------------------+| str_to_date(&#39;2022-12-12&#39;, &#39;%Y-%m-%d&#39;) |+---------------------------------------+| 2022-12-12                            |+---------------------------------------+1 row in set (0.00 sec)</code></pre><pre><code>- **unix_timestamp() 日期转时间戳，from_unixtime() 时间戳转日期**  ```SQL    # 默认会返回当前日期的时间戳    mysql&gt; select unix_timestamp();    +------------------+    | unix_timestamp() |    +------------------+    |       1676577902 |    +------------------+    1 row in set (0.00 sec)    mysql&gt; select from_unixtime(1676577911);    +---------------------------+    | from_unixtime(1676577911) |    +---------------------------+    | 2023-02-17 04:05:11       |    +---------------------------+    1 row in set (0.00 sec)</code></pre><ul><li><p><strong>date_add()、date_sub() 在日期上增加或删除时间</strong></p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select date_add(now(), interval 1 day);  +---------------------------------+  | date_add(now(), interval 1 day) |  +---------------------------------+  | 2023-02-18 04:12:41             |  +---------------------------------+  1 row in set (0.00 sec)  mysql> select date_add(now(), interval -1 day);  +----------------------------------+  | date_add(now(), interval -1 day) |  +----------------------------------+  | 2023-02-16 04:12:51              |  +----------------------------------+  1 row in set (0.00 sec)  mysql> select date_sub(now(), interval 1 day);  +---------------------------------+  | date_sub(now(), interval 1 day) |  +---------------------------------+  | 2023-02-16 04:13:00             |  +---------------------------------+  1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>两个日期间的运算</p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select datediff('2023-3-1', '2021-4-1');  +----------------------------------+  | datediff('2023-3-1', '2021-4-1') |  +----------------------------------+  |                              699 |  +----------------------------------+  1 row in set (0.00 sec)  mysql> select timediff('2023-3-1 23:14:57', '2021-4-1 10:13:15');  +----------------------------------------------------+  | timediff('2023-3-1 23:14:57', '2021-4-1 10:13:15') |  +----------------------------------------------------+  | 838:59:59                                          |  +----------------------------------------------------+  1 row in set, 1 warning (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>时间戳转换、增、减函数</p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select timestamp(now());  +---------------------+  | timestamp(now())    |  +---------------------+  | 2023-02-19 04:32:02 |  +---------------------+  1 row in set (0.00 sec)  mysql> select timestamp(now(), '10 04:00:00');  +---------------------------------+  | timestamp(now(), '10 04:00:00') |  +---------------------------------+  | 2023-03-01 08:29:26             |  +---------------------------------+  1 row in set (0.00 sec)  mysql> select timestampdiff(year, now(), '20201201');  +----------------------------------------+  | timestampdiff(year, now(), '20201201') |  +----------------------------------------+  |                                     -2 |  +----------------------------------------+  1 row in set (0.01 sec)  mysql> select timestampdiff(day, now(), '20201201');  +---------------------------------------+  | timestampdiff(day, now(), '20201201') |  +---------------------------------------+  |                                  -810 |  +---------------------------------------+  1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>时区转换函数（timezone）</p><pre class="line-numbers language-SQL"><code class="language-SQL">  mysql> select convert_tz(now(), '+08:00', '+00:00');  +---------------------------------------+  | convert_tz(now(), '+08:00', '+00:00') |  +---------------------------------------+  | 2023-02-18 20:36:40                   |  +---------------------------------------+  1 row in set (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><ul><li><p>count() 数量统计</p></li><li><p>avg() 求平均数</p></li><li><p>sum() 求和</p></li><li><p>max()、min() 取最大值、最小值</p></li><li><p>abs() 取绝对值</p></li><li><p>pow(x, y) 求x的y次方</p></li><li><p>truncate(x, y) x保留y位小数</p></li><li><p>mod(x, y) x除y取余</p></li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><p>char_length(s) 返回字符串s的长度</p></li><li><p>concat(s1, s2, …, sn) 将多个字符串合并，concat_ws(x, s1, s2, …, sn) 合并多个字符串并用x做分隔符</p></li><li><p>locate(s1, s) 在字符串s中获取字符串s1的开始位置</p></li><li><p>lower(s) 将字符串中所有字母变成小写，upper(s) 将字符串中所有字母变成大写</p></li><li><p>substr(s, n, len) 在字符串s中，从n位置开始截取长度为len的子字符串</p></li><li><p>replace(s, s1, s2) 在字符串s中，用s2替换所有s1</p></li><li><p>trim(s) 清除字符串s中所有空格</p></li></ul><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><pre class="line-numbers language-SQL"><code class="language-SQL"># if函数, 遵守非0为真0为假mysql> select if(0, 'true', 'false');+--------------------+| if(0, true, false) |+--------------------+| 0                  |+--------------------+1 row in set (0.00 sec)mysql> select if(1, 'true', 'false');+------------------------+| if(1, 'true', 'false') |+------------------------+| true                   |+------------------------+1 row in set (0.00 sec)mysql> select if(1>0, 'true', 'false');+----------------------+| if(1>0, true, false) |+----------------------+| 1                    |+----------------------+1 row in set (0.01 sec)# isnull 判断参数是否为空mysql> select isnull(null);+--------------+| isnull(null) |+--------------+|            1 |+--------------+1 row in set (0.00 sec)mysql> select isnull(1);+-----------+| isnull(1) |+-----------+|         0 |+-----------+1 row in set (0.00 sec)# ifnull(a, b) a为null返回b，否则返回amysql> select ifnull(null, 1);+-----------------+| ifnull(null, 1) |+-----------------+|               1 |+-----------------+1 row in set (0.00 sec)# database() 返回当前数据库名mysql> show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.02 sec)mysql> use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql> select database();+------------+| database() |+------------+| mysql      |+------------+1 row in set (0.00 sec)# current_user() 返回当前用户mysql> select current_user();+----------------+| current_user() |+----------------+| root@%         |+----------------+1 row in set (0.01 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h1><h2 id="通配符与模糊查询"><a href="#通配符与模糊查询" class="headerlink" title="通配符与模糊查询"></a>通配符与模糊查询</h2><ol><li><p>“%” 百分号通配符：表示任何字符出现任意次数（可以是0次）</p></li><li><p>“<em>“ 下划线通配符：表示只能匹配单个字符,不能多也不能少,就是一个字符。当然，也可以like “陈___</em>“，数量不限</p></li><li><p>like操作符：LIKE作用是指示 mysql 后面的搜索模式是利用通配符而不是直接相等匹配进行比较；但如果like后面没出现通配符，则在SQL执行优化时将 like 默认为 “=”执行</p></li></ol><pre class="line-numbers language-SQL"><code class="language-SQL"># 模糊查询语法，column_name(s)表示需要查询的列名，table_name表示需要查询的表名，pattern表示查询条件，可以使用通配符进行模糊匹配SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意：<br>    - 匹配前需要检查数据库是否配置了区分大小写<br>    - 匹配字符尾部空格要清除，否则会匹配不上<br>    - 通配符无法匹配到NULL<br>    - MySQL中的模糊查询可能会降低查询的效率，因为需要对所有可能匹配的记录进行扫描。因此，应该尽量避免使用通配符在查询条件的开头处，以提高查询效率</p></blockquote><h2 id="条件集查询（in）"><a href="#条件集查询（in）" class="headerlink" title="条件集查询（in）"></a>条件集查询（in）</h2><p>嵌套 SQL 可以使用子查询或者联结查询的方式在一个查询语句中进行多层嵌套。如果需要在查询结果中再次查找数据，可以将原始查询语句作为子查询，然后在子查询的结果中进行再次查询。</p><p>例如，假设有两个表格：订单表格和商品表格，其中订单表格中包含订单编号和商品编号，商品表格中包含商品编号和商品名称。如果要查询订单表格中所有包含特定商品的订单，可以使用如下的 SQL 语句：</p><pre class="line-numbers language-SQL"><code class="language-SQL">SELECT * FROM orders WHERE product_id IN (    SELECT product_id FROM products WHERE product_name = '特定商品')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="查询数据集排前的数据"><a href="#查询数据集排前的数据" class="headerlink" title="查询数据集排前的数据"></a>查询数据集排前的数据</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// mysqlSELECT TOP 5 * FROM 表// oracle（不支持top语法）SELECT * FROM 表 WHERE ROWNUM <= 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="限制查询数量（常用于数据分页）"><a href="#限制查询数量（常用于数据分页）" class="headerlink" title="限制查询数量（常用于数据分页）"></a>限制查询数量（常用于数据分页）</h2><pre class="line-numbers language-SQL"><code class="language-SQL">SELECT 列名称 FROM 表名称 LIMIT 数量 [OFFSET 偏移量];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>OFFSET后面为偏移量。OFFSET内容为可选项，当不填OFFSET内容时，默认输出设置数量的表内头部数据；当填入OFFSET偏移量，输出（数量~数量+偏移量）之间的数据。上边际不包含该数量位置的值，从+1开始记，例。</p><pre class="line-numbers language-SQL"><code class="language-SQL">select * from table_name limit 10 offset 10;// 不包含第10条数据，返回第11条到第20条，共计10条数据。也可以简写成如下select * from table_name limit 10, 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h2><p>在MySQL中，连接（Join）是指将多个表中的数据进行组合的操作。MySQL支持多种连接方式，包括内连接（INNER JOIN）、左连接（LEFT JOIN）、右连接（RIGHT JOIN）和外连接（FULL OUTER JOIN）。</p><ul><li><p>内连接（INNER JOIN）：内连接是最常用的连接方式，它只返回两个表中共同符合查询条件的记录。内连接使用JOIN关键字或直接使用表名进行连接，例如：</p><pre class="line-numbers language-SQL"><code class="language-SQL">  SELECT * FROM table1   JOIN table2   ON table1.column = table2.column;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202304271626332.png" alt="内连接"></p></li><li><p>左连接（LEFT JOIN）：左连接返回左边表中所有记录以及与之匹配的右边表中的记录。如果右边表中没有与之匹配的记录，则返回NULL值。左连接使用LEFT JOIN关键字进行指定，例如：</p><pre class="line-numbers language-SQL"><code class="language-SQL">  SELECT * FROM table1   LEFT JOIN table2   ON table1.column = table2.column;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202304271626330.png" alt="左连接"></p></li><li><p>右连接（RIGHT JOIN）：右连接返回右边表中所有记录以及与之匹配的左边表中的记录。如果左边表中没有与之匹配的记录，则返回NULL值。右连接使用RIGHT JOIN关键字进行指定，例如：</p><pre class="line-numbers language-SQL"><code class="language-SQL">  SELECT * FROM table1   RIGHT JOIN table2   ON table1.column = table2.column;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202304271626331.png" alt="右连接"></p></li><li><p>外连接（FULL OUTER JOIN）：外连接返回左边表和右边表中的所有记录，如果某个表中没有与之匹配的记录，则返回NULL值。MySQL不支持全外连接，但可以使用左外连接和右外连接的联合查询来模拟实现，例如：</p><pre class="line-numbers language-SQL"><code class="language-SQL">  SELECT * FROM table1   LEFT JOIN table2 ON table1.column = table2.column   UNION   SELECT * FROM table1   RIGHT JOIN table2 ON table1.column = table2.column;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// 基本语法（IN/OUT 表示输入输出参数）CREATE PROCEDURE `存储过程名称`(IN/OUT `参数名` 类型)BEGIN  // do somethingEND// 执行存储过程CALL 存储过程名称(参数);// 删除存储过程，IF EXISTS 指定这个关键字，用于防止因删除不存在的存储过程而引发的错误DROP PROCEDURE [ IF EXISTS ] <存储过程名称>// 查看全部存储过程SHOW PROCEDURE STATUS;// 查看存储过程内容SHOW CREATE PROCEDURE 存储过程名称;// 存储过程不支持修改内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储过程支持if、case、while、repeat、loop、ITERATE："><a href="#存储过程支持if、case、while、repeat、loop、ITERATE：" class="headerlink" title="存储过程支持if、case、while、repeat、loop、ITERATE："></a>存储过程支持if、case、while、repeat、loop、ITERATE：</h3><pre class="line-numbers language-SQL"><code class="language-SQL">if 条件 then ... else ... end if;case 变量 when 结果1 then ...; when 结果2 then ...; else ...; end case;while 循环条件 do ... end while;repeat ... until 循环条件 end repeat;LOOP_LABLE:loop ... leave LOOP_LABLE; end loop;  // leave LOOP_LABLE 指跳出循环，此外还有 iterate LOOP_LABLE 用于循环语句的迭代，即立即开始下次循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需要注意的是，存储过程在使用时需要考虑其性能和安全性，并且需要避免过度依赖存储过程，否则可能会导致数据库性能下降和维护困难。</strong></p><h1 id="库表操作"><a href="#库表操作" class="headerlink" title="库表操作"></a>库表操作</h1><h2 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h2><pre class="line-numbers language-SQL"><code class="language-SQL">CREATE DATABASE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改库属性"><a href="#修改库属性" class="headerlink" title="修改库属性"></a>修改库属性</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// 修改数据库名称ALTER DATABASE db_name RENAME TO new_db_name;// 修改数据库字符集ALTER DATABASE db_name CHARACTER SET utf8mb4;// 修改数据库排序规则ALTER DATABASE db_name COLLATE utf8mb4_general_ci;// 修改数据库存储引擎ALTER DATABASE db_name ENGINE=InnoDB;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>有些属性的修改可能会导致数据库中的数据丢失或发生不可逆的改变，一定要记得做好备份工作</strong></p><h2 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h2><pre class="line-numbers language-SQL"><code class="language-SQL">DROP DATABASE <数据库名>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><pre class="line-numbers language-SQL"><code class="language-SQL">CREATE TABLE IF NOT EXISTS '表名' (  'xxx_id' INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,  'xxx_name' VARCHAR(10) NOT NULL,  'xxx_role' VARCHAR(4) NOT NULL DEFAULT('user'),  'xxx_age' INT UNSIGNED NOT NULL CHECK ('xxx_age' BETWEEN 0 and 120),  'xxx_DATE' DATE,) ENGINE = InnoDB DEFAULT CHARSET=utf8;// 创建外键CREATE TABLE departments (    id INT PRIMARY KEY,    name VARCHAR(50));CREATE TABLE employees (    id INT PRIMARY KEY,    name VARCHAR(50),    department_id INT,    CONSTRAINT fk_department FOREIGN KEY (department_id) REFERENCES departments(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字段的增删改"><a href="#字段的增删改" class="headerlink" title="字段的增删改"></a>字段的增删改</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// 增加字段ALTER TABLE table_name ADD column_name column_type;// 修改字段类型ALTER TABLE table_name MODIFY column_name new_column_type;// 修改字段名称ALTER TABLE table_name CHANGE old_column_name new_column_name column_type;// 删除字段ALTER TABLE table_name DROP column_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改表字段可能会导致数据丢失，修改前需要备份数据</strong></p><h2 id="修改表属性"><a href="#修改表属性" class="headerlink" title="修改表属性"></a>修改表属性</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// 修改表名称ALTER TABLE old_table_name RENAME TO new_table_name;// 修改表的存储引擎ALTER TABLE table_name ENGINE = new_engine;// 添加索引ALTER TABLE table_name ADD INDEX index_name (column_name);// 删除索引ALTER TABLE table_name DROP INDEX index_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改表属性可能会导致数据丢失，修改前需要备份数据</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre class="line-numbers language-SQL"><code class="language-SQL">// 创建普通索引，索引值可出现多次CREATE INDEX index_name ON table_name (column_name);// 创建唯一索引，除了NULL外，NULL可能会出现多次CREATE UNIQUE INDEX index_name ON table_name (column_name);// 创建主键索引ALTER TABLE table_name ADD PRIMARY KEY (column_name);// 创建全文索引CREATE FULLTEXT INDEX index_name ON table_name (column_name);// 删除索引DROP INDEX [indexName] ON mytable;// 删除主键索引，删除主键索引表明将允许值为NULL或值重复，所以建议先将逐渐索引改为唯一索引，以此保证原数据完整性ALTER TABLE table_name DROP PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h2><pre class="line-numbers language-SQL"><code class="language-SQL">DROP TABLE [ IF EXISTS ] 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h2><pre class="line-numbers language-Plain"><code class="language-Plain">// 导出数据，不加表名表示导出整个库，加'-d'表示仅导出表结构，加'--databases'表示要导出多个数据库mysqldump -h IP地址 -P 端口 -u 用户名 -p [-d] [--databases] 数据库名 [表名] > 导出的文件名// 导入数据，导入前需要先创建同名数据库，在库中导入create database 库名;use 库名;source sql文件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>备份涉及到很多问题，比如物理备份、逻辑备份、增量备份，还可以借助第三方软件实现热备份。</p><p>逻辑备份比较好理解，使用mysqldump直接导出sql，打包备份就行，逻辑备份的缺点是不如物理备份速度快。</p><p>物理备份是指直接拷贝数据库目录中的文件转移到别的机器上，缺点是文件体积大，不够灵活。</p><p>MySQL 的增量备份是在全量备份的基础上，仅备份自上一次备份后新增或修改的数据。这种备份方式可以节省备份时间和存储空间，并且可以更快地恢复数据。</p><p>增量备份之前，需要在 MySQL 服务器上启用二进制日志功能。在备份之前，先使用 FLUSH LOGS 命令生成新的二进制日志文件，然后备份从上次备份之后产生的所有二进制日志文件。可以使用 mysqlbinlog 工具来转换二进制日志为 SQL 语句，然后将这些 SQL 语句应用到备份的数据库中。具体操作如下：</p><pre class="line-numbers language-Shell"><code class="language-Shell"># 启用二进制日志功能vi /etc/mysql/mysql.conf.d/mysqld.cnf# 在 [mysqld] 部分中添加以下行log-bin=/var/log/mysql/mysql-bin.log# 重启 MySQL 服务器sudo systemctl restart mysql# 生成新的二进制日志文件mysqladmin flush-logs# 备份从上次备份以来产生的所有二进制日志文件sudo cp /var/log/mysql/mysql-bin.* /path/backup/directory# 将二进制日志转换为 SQL 语句并应用到备份的数据库中mysqlbinlog /path/backup/directory/mysql-bin.* | mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在备份之前，应该停止 MySQL 服务以确保数据文件不被占用。</strong></p><p>此外在linux下可以使用crontab做定时逻辑备份或增量备份，以确保数据的可靠性</p>]]></content>
    
    <summary type="html">
    
      抽空整理了一份简要的sql语法文档，一边复习一边归纳。
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Nginx</title>
    <link href="https://xuanxiaoming.github.io/2022/11/27/linux%E5%AE%89%E8%A3%85nginx/"/>
    <id>https://xuanxiaoming.github.io/2022/11/27/linux%E5%AE%89%E8%A3%85nginx/</id>
    <published>2022-11-27T08:51:39.000Z</published>
    <updated>2023-04-27T09:09:36.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux安装Nginx"><a href="#Linux安装Nginx" class="headerlink" title="Linux安装Nginx"></a>Linux安装Nginx</h1><h3 id="一、安装nginx"><a href="#一、安装nginx" class="headerlink" title="一、安装nginx"></a>一、安装nginx</h3><p>使用 apt 来安装 Nginx</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo apt -y updatesudo apt -y install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>  <h3 id="二、配置防火墙"><a href="#二、配置防火墙" class="headerlink" title="二、配置防火墙"></a>二、配置防火墙</h3><p>在测试 Nginx 之前，我们需要调整防火墙，让他允许 Nginx 服务通过。Nginx ufw 在安装时会把他自身注册成为服务。</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo ufw app list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-Plain"><code class="language-Plain">Available applications:  Nginx Full  Nginx HTTP  Nginx HTTPS  OpenSSH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nginx 提供了三个配置文件：</p><ul><li><p><strong>Nginx Full</strong><br>开端口80 正常，未加密的网络流量<br>端口443 TLS / SSL加密的流量</p></li><li><p><strong>Nginx HTTP</strong><br>仅打开端口80 正常，未加密</p></li><li><p><strong>Nginx HTTPS</strong><br>仅打开端口443 TLS / SSL加密</p></li></ul><br>先测试HTTP，配置防火墙允许服务通过<pre class="line-numbers language-Shell"><code class="language-Shell">sudo ufw allow 'Nginx HTTP'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>  <h3 id="三、检查web服务器"><a href="#三、检查web服务器" class="headerlink" title="三、检查web服务器"></a>三、检查web服务器</h3><p>用以下命令来查看更改结果</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo ufw status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以在输出结果中看到</p><pre class="line-numbers language-Shell"><code class="language-Shell">Status: activeTo                         Action      From--                         ------      ----OpenSSH                    ALLOW       Anywhere                  Nginx HTTP                 ALLOW       Anywhere                  OpenSSH (v6)               ALLOW       Anywhere (v6)             Nginx HTTP (v6)            ALLOW       Anywhere (v6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若未看到上述结果，先检查nginx服务是否开启</p><pre class="line-numbers language-Shell"><code class="language-Shell">service nginx status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到 <code>Active: active (running)</code> 说明已启动</p><p>使用以下命令检查内网ip</p><pre class="line-numbers language-Shell"><code class="language-Shell">ip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\/.*$//'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用以下命令检查公网ip</p><pre class="line-numbers language-Shell"><code class="language-Shell">curl -4 icanhazip.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当nginx服务运行后可以在浏览器访问<a href="http://本地IP" target="_blank" rel="noopener">http://本地IP</a></p><br>  <h3 id="四、管理nginx"><a href="#四、管理nginx" class="headerlink" title="四、管理nginx"></a>四、管理nginx</h3><p>停止、启动、重启、配置服务器跟随系统启动，配置不跟随服务器启动，热加载配置</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo service nginx stopsudo service nginx startsudo service nginx restartsudo service nginx disablesudo service nginx enablesudo service nginx reload  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><h3 id="五、设置服务块"><a href="#五、设置服务块" class="headerlink" title="五、设置服务块"></a>五、设置服务块</h3><p>如果是部署到公网上以供公共访问，首先需要准备一个域名</p><p>假设网站是 <code>http://example.com</code></p><p>nginx默认前端资源存储位置在 <code>/var/www</code></p><p>先在该路径下创建存放网页资源的文件夹，路径为 <code>/var/www/example.com/html</code>，然后为该文件夹分配权限</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo chown -R $USER:$USER /var/www/example.com/htmlsudo chmod -R 755 /var/www/example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先随便添加一个网页做测试</p><pre class="line-numbers language-Shell"><code class="language-Shell">vim /var/www/example.com/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容随便写一个 <code>&lt;h1&gt;HELLO WORLD!&lt;/h1&gt;</code></p><p>接下来要在nginx的服务中创建一个新的服务器块</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo vim /etc/nginx/sites-available/example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-Shell"><code class="language-Shell">server {        listen 80;        listen [::]:80;        root /var/www/example.com/html;        index index.html index.htm index.nginx-debian.html;        server_name example.com www.example.com;        location / {                try_files $uri $uri/ =404;        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为上述文件创建链接，让nginx启动时读取目录</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为避免可能由于添加其他服务器名称而引起的哈希存储区内存问题，有必要调整 <code>/etc/nginx/nginx.conf</code> 文件中的单个值</p><pre class="line-numbers language-Shell"><code class="language-Shell">http {    ...    # 找到这行，将注释去掉    server_names_hash_bucket_size 64;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启nginx</p><pre class="line-numbers language-Shell"><code class="language-Shell">sudo service nginx restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查一下nginx的运行状态之后，就可以尝试在浏览器访问 <code>http://example.com</code></p><br><h3 id="六、-一些重要路径"><a href="#六、-一些重要路径" class="headerlink" title="六、 一些重要路径"></a>六、 一些重要路径</h3><p><code>/etc/nginx Nginx</code> 配置目录。所有 Nginx 的配置文件都在这里</p><p><code>/etc/nginx/nginx.conf</code> Nginx的配置文件。大多数全局配置可以通过这个文件来修改</p><p><code>/etc/nginx/sites-available/sites-enabled</code> 用来存储服务器下每个站点服务器块的目录。 默认情况下 Nginx 不会直接使用目录下的配置文件，需要我们更改配置来告诉 Nginx 来去读</p><p><code>/etc/nginx/sites-enabled/sites-available</code> 这里是存储已经启用站点服务器块的目录</p><p><code>/etc/nginx/snippets</code> 这个目录包含一些 Nginx 的配置文件。可打开详细查看这些配置文件到文档进行学习</p><p><code>/var/log/nginx/access.log</code> 这里是 Nginx 到日志文件，对 Web 服务器的每个请求都会记录在这个日志中</p><p><code>/var/log/nginx/error.log</code> 记录 Nginx 运行过程中发生的错误日志</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux安装Nginx&quot;&gt;&lt;a href=&quot;#Linux安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;Linux安装Nginx&quot;&gt;&lt;/a&gt;Linux安装Nginx&lt;/h1&gt;&lt;h3 id=&quot;一、安装nginx&quot;&gt;&lt;a href=&quot;#一、安装
      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统检查与故障诊断</title>
    <link href="https://xuanxiaoming.github.io/2022/11/07/linux%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%9F%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/"/>
    <id>https://xuanxiaoming.github.io/2022/11/07/linux%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%9F%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E8%AF%8A%E6%96%AD/</id>
    <published>2022-11-06T17:07:34.000Z</published>
    <updated>2023-01-29T19:56:51.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="硬件信息检查"><a href="#硬件信息检查" class="headerlink" title="硬件信息检查"></a>硬件信息检查</h2><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p><strong>功能说明</strong>：显示开机信息。显示系统运行时硬件的检测或者断开连接信息。</p><blockquote><p>使用前注意权限问题，内核日志是限制非管理员权限阅读的。遇到 <code>dmesg: read kernel buffer failed: Permission denied</code>，先修改权限，使用命令<code>sudo sysctl -w kernel.dmesg_restrict=0</code>  <br><br>在ubuntu 20.1以上版本中，还可以更改 <code>/etc/sysctl.d/10-kernel-hardening.conf</code> 中的配置 <code>kernel.dmesg_restrict=0</code>，再执行 <code>sudo service procps restart</code> 使其生效。<br><br>另外如果是docker容器中，修改权限会遇到 <code>sysctl: setting key &quot;kernel.yama.ptrace_scope&quot;, ignoring: Read-only file system</code>，解决办法请参考 <a href="http://fleey.cn/archives/108.html" target="_blank" rel="noopener">http://fleey.cn/archives/108.html</a></p></blockquote><br>dmesg 命令显示 linux 内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信 息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备。    <br><br>dmesg 命令用于设备故障的诊断是非常重要的。进行硬件的连接或断开连接操作时，在 dmesg 命令的帮助下，我们可以看到硬件的检测或者断开连接的信息。dmesg 命令在多数基于Linux和Unix的操作系统中都可以使用。<br><br>  <p><strong>常用</strong>  </p><ol><li>查看网卡启动信息 <code>dmesg | grep eth</code></li><li>列出所有被检测到的硬件 <code>dmesg | grep sda</code></li><li>清空dmesg缓冲区日志 <code>dmesg -c</code>， 即使清除了缓冲区数据也可以查看日志文件，文件保存在 <code>/var/log/dmesg</code></li><li>监控硬件变化 <code>dmesg | tail -20</code></li></ol><h3 id="lshw"><a href="#lshw" class="headerlink" title="lshw"></a>lshw</h3><p><strong>功能说明</strong>：检查全部硬件信息</p><p>需要安装软件包  </p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y lshw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h3><p><strong>功能说明</strong>：检查PCI设备</p><p>需要安装软件包  </p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y lshw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="lsusb"><a href="#lsusb" class="headerlink" title="lsusb"></a>lsusb</h3><p><strong>功能说明</strong>：检查USB设备</p><br>   <h2 id="网络检查"><a href="#网络检查" class="headerlink" title="网络检查"></a>网络检查</h2><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p><strong>功能说明</strong>：查看进程打开的文件、目录，以及查看进程监听的端口等 socket 相关的信息  </p><p>需要安装软件包</p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y lsof<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查结果解释：</p><ol><li>COMMAND：程序的名称</li><li>PID：进程标识符</li><li>USER：进程所有者</li><li>FD：文件描述符，应用程序通过文件描述符识别该文件<br>FD 列中的常见内容有 cwd、rtd、txt、mem 和一些数字等等。<br>其中 cwd 表示当前的工作目录；rtd 表示根目录；txt 表示程序的可执行文件；mem 表示内存映射文件；标准输入输出文件通常以数字表示。</li><li>TYPE：文件类型，如 DIR、REG 等<br>REG 和 DIR 分别表示普通文件和目录。</li><li>DEVICE：以逗号分隔设备编号</li><li>SIZE：文件的大小(bytes)</li><li>NODE：索引节点(文件在磁盘上的标识)</li><li>NAME：打开文件的确切名称  </li></ol><p><strong>常用</strong>：</p><ol><li>查看哪些进程打开了某个文件或设备<br>直接指定文件（设备）的名称作为 lsof 的参数就可以查看哪些进程打开了这个文件（设备），例：<code>lsof /bin/bash</code> 或 <code>lsof /dev/sda1</code></li><li>查看哪些进程打开了某个目录及目录下的文件<pre class="line-numbers language-shell"><code class="language-shell"> lsof +d /var/log  #不递归查询 lsof +D /var/log  #递归查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>查看某个进程打开的所有文件<br>先用ps查询进程的PID，再用lsof查询，用bash举例<pre class="line-numbers language-shell"><code class="language-shell"> ps -C bash lsof -p bash的PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>复杂查询条件<ul><li>使用 <code>-a</code> 参数，使查询组合多个条件</li><li><code>-c</code> 使多条件为或的关系</li><li>对条件取反，则直接在条件前加 <code>^</code></li><li>另外也可以使用正则表达式，使用 <code>/</code> 包裹表达式</li></ul></li><li>只列出 IPv4 或 IPv6 打开的文件<pre class="line-numbers language-shell"><code class="language-shell"> lsof -i 4  #IPv4 lsof -i 6  #IPv6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>列出与某端口相关的文件，例：<code>lsof -i:22</code></li><li>列出指定范围内被打开的 TCP 端口，例：<code>lsof -i TCP:1-1024</code></li><li>查看某个用户打开的所有文件，例：<code>lsof -u root</code></li></ol><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p><strong>功能说明</strong>：显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p><p><strong>常用</strong>：</p><ol><li>列出所有端口 <code>netstat -a</code>，默认不显示监听状态栏</li><li>列出所有 tcp 端口 <code>netstat -at</code></li><li>列出所有 udp 端口 <code>netstat -au</code></li><li>列出所有监听端口 <code>netstat -l</code></li><li>列出特定进程的使用端口 <code>netstat -p [PID]</code></li><li>持续输出 netstat 信息 <code>netstat -c</code></li><li>显示核心路由信息 <code>netstat -r</code></li><li>显示网络接口列表 <code>netstat -i</code></li></ol><blockquote><p><strong>什么是监听端口</strong><br>首先了解一下TCP/IP协议中的端口指的是什么？如果把IP地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有一个或者几个门，但是一个IP地址下的端口可以有65536（即：256×256）个之多！端口是通过端口号来标记的，端口号只有整数，范围是从0到65535（256×256-1）。<br><br>在互联网上主机与主机之间通过TCP/IP协议发送和接收数据包，各个数据包根据其目的主机IP地址来进行路由。当数据包顺利的被传送到目的主机后，它要如何进入主机呢？当然是要通过端口(现实中的门)进入了。我们知道大多数操作系统都支持多应用程序（多进程）同时运行，不同的应用具有不同的处理功能，那么目的主机应该把接收到的数据包传送给哪一个应用程序呢？这就要靠端口了，一个应用对应一个或多个端口，这样我们就可以把数据包传递给对应的程序了。这就是监听端口的由来。<br><br>同一个端口只能被一个应用程序使用。如果多个应用使用了相同端口，就会出现端口冲突问题。这种情况通常我们不需要担心，因为端口冲突会导致应用程序无法启动。</p></blockquote><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p><strong>功能说明</strong>：根据使用者的定义对网络上的数据包进行截获的包分析工具。支持与或非逻辑语句帮助筛选信息。  </p><p>需要安装软件包</p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y tcpdump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出信息的描述:   </p><ul><li>时间精确到微秒</li><li>localhost.42333 &gt; localhost.9501 表示通信的流向</li><li>[S] 表示这是一个SYN请求</li><li>[.] 表示这是一个ACK确认包，(client)SYN-&gt;(server)SYN-&gt;(client)ACK 就是3次握手过程</li><li>[P] 表示这个是一个数据推送，可以是从服务器端向客户端推送，也可以从客户端向服务器端推</li><li>[F] 表示这是一个FIN包，是关闭连接操作，client/server都有可能发起</li><li>[R] 表示这是一个RST包，与F包作用相同，但RST表示连接关闭时，仍然有数据未被处理。可以理解为是强制切断连接</li><li>win 342是指滑动窗口大小</li><li>length 12指数据包的大小  </li></ul><p>查看数据包的详细信息，使用 <code>-XX -vvv -nn</code>：</p><ul><li><code>-v</code> 当分析和打印的时候，产生详细的输出。</li><li><code>-vv</code> 产生比-v更详细的输出。</li><li><code>-vvv</code> 产生比-vv更详细的输出。</li><li><code>-XX</code> 输出包的头部数据，会以16进制和ASCII两种方式同时输出。</li><li><code>-nn</code> 直接以IP以及PORT number显示，而非主机名与服务名称。</li></ul><p><strong>常用</strong>：  </p><ol><li>监视指定主机的数据包 <code>tcpdump host 主机IP</code></li><li>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信 <code>tcpdump host 210.27.48.1 and \(210.27.48.2 or 210.27.48.3 \)</code></li><li>获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包 <code>tcpdump ip host 210.27.48.1 and ! 210.27.48.2</code></li><li>监视指定主机和端口的数据包 <code>tcpdump tcp port 23 and host 210.27.48.1</code></li><li>对本机的UDP 222端口进行监视 <code>tcpdump udp port 222</code>  </li><li>检查数据包的详细信息：</li></ol><br><h2 id="系统模块检查"><a href="#系统模块检查" class="headerlink" title="系统模块检查"></a>系统模块检查</h2><h3 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h3><p><strong>功能说明</strong>：检查当前内核已经加载的模块和驱动</p><p>需要安装软件包  </p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y kmod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查结果通常有三列，分别是： </p><ol><li>模块名称（Module）</li><li>模块的大小（Size）</li><li>此模块是否被其他模块使用（Used by）</li></ol><br><h2 id="系统状态检查"><a href="#系统状态检查" class="headerlink" title="系统状态检查"></a>系统状态检查</h2><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><strong>功能说明</strong>：显示指定的目录或文件所占用的磁盘空间</p><p><strong>常用</strong>:</p><ol><li><code>du -h</code> 将空间大小换算成更易读的k、m、g</li><li><code>du -D</code> 显示链接文件的原文件大小</li></ol><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p><strong>功能说明</strong>：显示目前在 Linux 系统上的文件系统磁盘使用情况统计</p><p><strong>常用</strong>:</p><ol><li><code>df -h</code> 将空间大小换算成更易读的k、m、g</li><li><code>du -a</code> 输出所有文件的磁盘用量，不仅仅是目录</li><li><code>du -d</code> 仅当目录（或在 –all 选项启用时包括文件）层级不高于命令行参数指定的 N 层时输出对应目录或文件的对应大小</li><li><code>du --time</code> 显示目录中或其子目录下所有文件的最后修改时间</li></ol><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p><strong>功能说明</strong>：以树状图形式列出目录的内容</p><p><strong>常用</strong>：</p><ol><li><code>tree -a</code> 列出所有文件</li><li><code>tree -d</code> 仅列出目录</li><li><code>tree -f</code> 列出每个文件的完整路径</li><li><code>tree -L 数字</code> 列出的目录深度</li><li><code>tree --charset UTF8</code> 设置字符集，将来用于终端或HTML展示</li><li><code>-u</code> 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码<br><code>-g</code> 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码</li><li><code>tree -p</code> 列出文件权限</li><li><code>tree -h</code> 将空间大小换算成更易读的k、m、g</li><li><code>tree -D</code> 显示上次修改或状态更改的日期<br><code>--timefmt</code> 根据格式打印并格式化时间，例如：’%F %T’ 或 ‘%c’</li><li><code>-v</code> 按字母排序<br><code>-t</code> 按最后修改的时间排序<br><code>-c</code> 按上次状态更改时间对文件排序<br><code>-r</code> 反转排序的顺序<br><code>--dirsfirst</code> 在文件之前列出目录</li><li>输出：<br><code>-X</code> 打印出树的XML表示<br><code>-J</code> 打印出树的 JSON 表示<br><code>-H 根名</code> 输出为网页表示，参数为根名，会影响超链接，建议用 <code>.</code>；<code>-T 标题</code> 替换默认的 HTML 标题和 H1 标题，<code>--nolinks</code> 关闭 HTML 输出中的超链接</li></ol><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p><strong>功能说明</strong>：动态监视系统的磁盘操作活动</p><p><strong>常用</strong>：</p><ol><li><code>-c</code> 显示CPU资源情况</li><li><code>-d</code> 显示磁盘使用情况</li><li><code>-h</code> 改变显示单位，使其更加易读</li><li><code>iostat delay count</code> delay表示每隔几秒刷新一次，count表示总共输出几次</li></ol><blockquote><p>cpu属性值说明：<br>%user：CPU处在用户模式下的时间百分比。<br>%nice：CPU处在带NICE值的用户模式下的时间百分比。<br>%system：CPU处在系统模式下的时间百分比。<br>%iowait：CPU等待输入输出完成时间的百分比。<br>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。<br>%idle：CPU空闲时间百分比。</p></blockquote><blockquote><p>disk属性值说明：<br>rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/s<br>wrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/s<br>r/s: 每秒完成的读 I/O 设备次数。即 rio/s<br>w/s: 每秒完成的写 I/O 设备次数。即 wio/s<br>rsec/s: 每秒读扇区数。即 rsect/s<br>wsec/s: 每秒写扇区数。即 wsect/s<br>rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。<br>wkB/s: 每秒写K字节数。是 wsect/s 的一半。<br>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。<br>avgqu-sz: 平均I/O队列长度。<br>await: 平均每次设备I/O操作的等待时间 (毫秒)。<br>svctm: 平均每次设备I/O操作的服务时间 (毫秒)。<br>%util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</p></blockquote><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p><strong>功能说明</strong>：实时动态监视操作系统的虚拟内存、进程、CPU活动</p><p><strong>常用</strong>:</p><ol><li><code>-n</code> 表示在周期性循环输出时，输出的头部信息仅显示一次</li><li><code>vmstat delay count</code> delay表示每隔几秒刷新一次，count表示总共输出几次</li></ol><p><strong>字段说明</strong>：  </p><p>Procs（进程）:</p><ul><li>r: 运行队列中进程数量</li><li>b: 等待IO的进程数量  </li></ul><p>Memory（内存）:</p><ul><li>swpd: 使用虚拟内存大小</li><li>free: 可用内存大小</li><li>buff: 用作缓冲的内存大小<br>-cache: 用作缓存的内存大小  </li></ul><p>Swap:</p><ul><li>si: 每秒从交换区写到内存的大小</li><li>so: 每秒写入交换区的内存大小  </li></ul><p>IO：（现在的Linux版本块的大小为1024bytes）</p><ul><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数  </li></ul><p>system：</p><ul><li>in: 每秒中断数，包括时钟中断</li><li>cs: 每秒上下文切换数  </li></ul><p>CPU（以百分比表示）</p><ul><li>us: 用户进程执行时间(user time)</li><li>sy: 系统进程执行时间(system time)</li><li>id: 空闲时间(包括IO等待时间)</li><li>wa: 等待IO时间</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><strong>功能说明</strong>：显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等</p><p><strong>常用</strong>:</p><ol><li><code>-h</code> 改变显示单位，使其更加易读</li><li><code>-t</code> 显示总和</li><li><code>free -s delay -c count</code> -s后面delay表示每隔几秒刷新一次，-c后面count表示总共输出几次</li></ol>]]></content>
    
    <summary type="html">
    
      linux系统状态的检查方式，以及会涉及到的问题排查方法
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建填坑记录三</title>
    <link href="https://xuanxiaoming.github.io/2022/05/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B8%89/"/>
    <id>https://xuanxiaoming.github.io/2022/05/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%B8%89/</id>
    <published>2022-04-30T16:23:31.000Z</published>
    <updated>2022-05-05T18:57:00.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>许久未更新博客主要是自己随便做做笔记比较快速，不需要考虑排版问题。最近突然想把之前整理的笔记都放进去，看起来比较美观也方便，就掏出来用了，结果发现一大堆问题，只好重新装修了一下。</p></blockquote><p>这次大概解决的问题如下，我会挑一些重点来细讲：</p><ul><li>修改博客评论插件，之前的因为中国网络审核的原因被屏蔽了</li><li>修改图床为腾讯云存储桶，之前的图床CDN因为中国网络审核的原因被屏蔽了</li><li>修改资源CDN调用，之前的CDN因为中国网络审核的原因被屏蔽了</li><li>由于浏览器内核升级导致vue2中部分方法过时失效，故将vue2升级到了vue3</li><li>检查出博文代码中的 <code>{</code> 与vue标记语言冲突导致的页面渲染bug</li><li>将之前使用的代码插件从highlight.js更换为prismjs，换了新的样式</li><li>修复左侧导航栏的一处链接BUG</li><li>为首页文章列表增加显示标签，并修改样式</li><li>修复博客之前错误的国际化(i18n)使用，并增加部分内容</li><li>解决了在mac中使用nodejs引发的hexo渲染错误</li><li>解决了safari上不支持的日期格式引发的显示错误</li><li>增加了新的博文、更新了关于页面内容、微调部分样式</li></ul><h2 id="先说说最令我头疼的mac下使用nodejs的问题"><a href="#先说说最令我头疼的mac下使用nodejs的问题" class="headerlink" title="先说说最令我头疼的mac下使用nodejs的问题"></a>先说说最令我头疼的mac下使用nodejs的问题</h2><p>一开始我安装的nodejs最新的稳定版，使用hexo去生成静态文件，一会给我报一个权限不足的问题，一会又给我报一个无法解析ejs。那我就去改文件夹权限、重装package.json里的包嘛，但是问题仍然存在。这个问题一上来就摆在我面前，折磨了我好几天，我甚至一度准备放弃继续使用hexo。</p><p>后来我在网上看到有人也遇到这个问题，他说是nodejs在mac上存在问题，需要将nodejs版本降到12。</p><p>好了，我降到12后，上述两个问题确实不发生了，但是又出现了新的问题：</p><pre class="line-numbers language-shell"><code class="language-shell">FATAL {  err: [Error: EISDIR: illegal operation on a directory, open '/home/***'] {    errno: -21,    code: 'EISDIR',    syscall: 'open',    path: '/home/***'  }} Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个问题并不是不能解决，只是解决办法和我的需求冲突，但最后我还是妥协了，没有其他办法了，甚至连hexo的官方issue里都没给出第二种解决办法。</p><p><strong>解决办法是将 <code>_config.yaml</code> 文件里的 post_asset_folder 设置为 false，即可解决，但同时 hexo 也不再为文章生成资源文件夹。</strong></p><p>本来我是挺想为博文的资源文件做一份备份的，但是现在不得不放弃这个想法了，以后博文的内容我尽量用文字的方式记录吧。</p><p>在解决这个问题的同时，这个解决办法也为我解决了另外一个问题，所以也算是一石二鸟了，下面来说一说。</p><h2 id="博客各种CDN故障、云评论仓库被封锁"><a href="#博客各种CDN故障、云评论仓库被封锁" class="headerlink" title="博客各种CDN故障、云评论仓库被封锁"></a>博客各种CDN故障、云评论仓库被封锁</h2><p>因为是在线静态博客，以轻量化为主，所以所有的包用的都是在线的CDN链接，包括之前使用的图床、评论插件、以及开发用的包都是。</p><p>其中最常用的就是图床了，为了免费和访问速度，之前一直都是用GitHub仓库做云存储，然后用jsdelivr做免费的CDN加载（直接访问仓库文件会非常慢），但现在因为网络审核的缘故，匿名的jsdelivr已被中国封了，我只好更换图床了。</p><p>我选择使用的是腾讯云的COS服务，需要付费，但价格比较便宜。我购买的10G 2年的使用权，总共不到20块钱，这就是上一节提到的“一石二鸟”，不仅解决了存储问题，也解决了CDN的问题。</p><p>开发用的包这个太好解决了，遍地都有免费CDN提供，直接更换就好。而评论插件这边，又是一顿折腾，哎。</p><h2 id="更改评论插件"><a href="#更改评论插件" class="headerlink" title="更改评论插件"></a>更改评论插件</h2><p>我这一次打开博客的第一反应就是，之前小伙伴们给我的评论都没有了，我起初还是挺蒙的，但这个问题并不是首先要解决的，所以稍微往后放了放。</p><p>后来我在检查Valine这个评论插件的时候，发现其版本更新导致很多过时功能都无法使用了，于是我就改嘛，捣鼓了好长时间都改好了，但进页面看还是没有。</p><p>偶然间我在issue中看到有其他人也遇到这个问题，这个问题是因为国内审核要求禁止评论使用国际服域名，这下就破案了，以前为了不花钱买域名，使用的国际服<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，这个是Valine的云数据库。看样子现在强制使用国内备案域名了，想继续使用国际服必须配置好Valine的serverURLs参数。</p><p>看到这我立马就去配置了serverURLs，但是问题并没有解决。我确实看到请求的数据已经发来，但不知为什么就是绑定不到页面上去，折腾了很久，我决定弃坑了，想着要是Valine以后继续更新，每次更新都得这么大费周章的重新配置，甚至以后还可能强制要求备案域名，我为啥不使用更加成熟的方案呢。</p><p>于是我更换了韩国的<a href="https://www.livere.com/" target="_blank" rel="noopener">来必力</a>，配置及其简单，只需注册账户然后将嵌入代码贴到你需要的地方就行，相当的省心。</p><h2 id="hexo渲染错误"><a href="#hexo渲染错误" class="headerlink" title="hexo渲染错误"></a>hexo渲染错误</h2><p>上述问题都解决完后，博客就可以正常使用了，于是我加了几篇博文。在使用 <code>hexo g</code> 渲染后发现，渲染过程正常、文件也正常，但就是页面空白，什么也没有，当时问题处理到这已经头脑发热了，不知道又是哪出了问题。</p><p>即使现在去回忆处理问题的过程，我也记不清了。当时一点点排查问题，最后发现是因为博文中引用的代码使用了 <code>{</code> 标记，而这个vue使用的也是这个标记，所以网页渲染就出现了问题，具体解决办法我现在也没有，毕竟我也不是专业的前端工程师，我现在已将博文中出现的 <code>{</code> 替换为 <code>[</code> ，反方向的括号同理，共计两处更改。</p><h2 id="移动端浏览器上不显示博客运行时间，显示为NaN"><a href="#移动端浏览器上不显示博客运行时间，显示为NaN" class="headerlink" title="移动端浏览器上不显示博客运行时间，显示为NaN"></a>移动端浏览器上不显示博客运行时间，显示为NaN</h2><p>最后值得一提的就是这个问题，一开始我以为是手机浏览器屏蔽了js脚本，于是我把Safari高级设置里的选项都开了，结果还是这个问题。</p><p>然后我在脚本中加 <code>console.info()</code> 慢慢调试，发现从 <code>new Date()</code> 那里拿来的值就已经是NaN了。</p><p>上网一搜才知道，Safari和Chrome对于日期的格式支持不同，修改一下就好了。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// Safari不支持的格式</span><span class="token keyword">const</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2021-08-09'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Safari支持的格式</span><span class="token keyword">const</span> nDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">'2021, 07, 06'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// yyyy, mm, dd</span><span class="token keyword">const</span> nDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">,</span> <span class="token number">07</span><span class="token punctuation">,</span> <span class="token number">06</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">05</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// yyyy, mm, dd, hh, mm, ss</span><span class="token keyword">const</span> nDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">07</span><span class="token operator">/</span><span class="token number">06</span><span class="token operator">/</span><span class="token number">2021</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mm/dd/yyyy</span><span class="token keyword">const</span> nDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">07</span><span class="token operator">/</span><span class="token number">06</span><span class="token operator">/</span><span class="token number">2021</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">05</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mm/dd/yyyy hh:mm:ss</span><span class="token keyword">const</span> nDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>Tue Jul <span class="token number">06</span> <span class="token number">2021</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">05</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Day Mon dd yyyy hh:mm:ss</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      这次修复的问题也太多太杂了，博客终于恢复了可用状态。
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装记录</title>
    <link href="https://xuanxiaoming.github.io/2022/04/15/MySQL%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <id>https://xuanxiaoming.github.io/2022/04/15/MySQL%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-14T18:03:37.000Z</published>
    <updated>2022-05-15T04:44:32.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先是卸载问题：如果安装-mysql-错误，请按如下标准卸载："><a href="#首先是卸载问题：如果安装-mysql-错误，请按如下标准卸载：" class="headerlink" title="首先是卸载问题：如果安装 mysql 错误，请按如下标准卸载："></a>首先是卸载问题：如果安装 mysql 错误，请按如下标准卸载：</h3><pre class="line-numbers language-shell"><code class="language-shell"># 关闭mysql服务sudo service stop mysql；# 清除所有mysql包sudo apt purge mysql-server mysql-client mysql-common mysql-server-core-* mysql-client-core-*# 删除所有mysql文件sudo rm -rf /etc/mysql /var/lib/mysql /var/log/mysql# 最后清理所有不需要的包sudo apt autoremovesudo apt autoclean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="找不到-var-run-mysqld-mysqld-sock-报错"><a href="#找不到-var-run-mysqld-mysqld-sock-报错" class="headerlink" title="找不到 /var/run/mysqld/mysqld.sock 报错"></a>找不到 /var/run/mysqld/mysqld.sock 报错</h3><p>如果启动 mysql 时遇到 <code>Error: Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2)</code>，请仔细确认安装时是否有报错信息，根据报错原因去解决问题。</p><p>这类问题主要是my.cnf的配置指向错误，网上解决办法有很多种，请自行选择。</p><p>我自己遇到的是安装时提示 <code>mysql-server depends on mysql-server-8.0</code>，因为我是直接安装的 <code>mysq-server</code>，卸载重装时将安装包改为 <code>mysql-server-8.0</code> 就好了。</p><pre class="line-numbers language-shell"><code class="language-shell">apt install -y mysql-server-8.0 mysql-common<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="初始化mysql"><a href="#初始化mysql" class="headerlink" title="初始化mysql"></a>初始化mysql</h3><p>在使用 mysql 前，先使用 <code>mysql_secure_installation</code> 初始化数据库。</p><blockquote><p>初始化数据库遇到 <code># Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server</code>, 先退出进程，直接mysql进入数据库，运行 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password by &#39;mynewpassword&#39;;’</code> 更改身份验证参数，然后重新初始化。（密码为 mynewpassword）</p></blockquote><p>附上初始化过程：</p><pre class="line-numbers language-shell"><code class="language-shell">root@6f72ddf70108:/# mysql_secure_installationSecuring the MySQL server deployment.Enter password for user root: The 'validate_password' component is installed on the server.The subsequent steps will run with the existing configurationof the component.Using existing password for root.Estimated strength of the password: 50 Change the password for root ? ((Press y|Y for Yes, any other key for No) : yNew password: Re-enter new password: Estimated strength of the password: 0 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y ... Failed! Error: Your password does not satisfy the current policy requirementsNew password: Re-enter new password: Sorry, passwords do not match.New password: Re-enter new password: Estimated strength of the password: 50 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n ... skipping.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mysql-启动失败：su-warning-cannot-change-directory-to-nonexistent-No-such-file-or-directory"><a href="#mysql-启动失败：su-warning-cannot-change-directory-to-nonexistent-No-such-file-or-directory" class="headerlink" title="mysql 启动失败：su: warning: cannot change directory to /nonexistent: No such file or directory"></a>mysql 启动失败：su: warning: cannot change directory to /nonexistent: No such file or directory</h3><pre class="line-numbers language-shell"><code class="language-shell">sudo service mysql stopsudo usermod -d /var/lib/mysql/ mysqlsudo service mysql start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      好久没在机器上直接安装 mysql 了，这次安装遇到了点问题，顺手记录一下。
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>google搜索语法</title>
    <link href="https://xuanxiaoming.github.io/2022/02/20/google%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/"/>
    <id>https://xuanxiaoming.github.io/2022/02/20/google%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/</id>
    <published>2022-02-20T11:28:02.000Z</published>
    <updated>2022-11-05T13:20:24.908Z</updated>
    
    <content type="html"><![CDATA[<ul><li>（通配符）添加星号作为未知单词或事实的占位符，例如：”白*病”</li><li>“”（引号）用于准确查找一个单词或者句子  </li><li>OR（或）用OR分隔搜索词，同时执行两个搜索查询，这将找到包含多个单词之一的页面。</li><li>-（除去）将某些关键词结果从搜索结果中排除</li><li>~（近似）使用波浪号获得目标关键词及其近似词的搜索结果，例如：查找SEO方面的教程，语法：SEO ~教程</li><li>..（范围）用两个句点分隔数字，不带空格，以搜索该范围内的数字</li><li>intitle/allintitle (在网页标题中搜索包含关键字的结果)<br>  注：allintitle是排他指令，不可以与其他指令混用</li><li>intext/allintext（在网页正文中搜索包含关键字的结果）<br>  注：allintext是排他指令，不可以与其他指令混用</li><li>inurl/allinurl/inanchor  <ul><li>inurl/allinurl（在网页的url中搜索包含关键字的结果），allinurl是排他指令，不可以与其他指令混用  </li><li>inanchor（在网页的锚链接中搜索关键字文本），即在网页中搜索指向该url地址的超链接（<code>&lt;a&gt;搜索词&lt;/a&gt;</code>）</li></ul></li><li>site:（使用site:[URL]将搜索结果限制到特定网站）</li><li>filetype:（使用filetype:[后缀]将结果限制为特定的文件格式）</li><li>location:（使用location:[地点]查看某个地区内的相关信息） </li><li>define:（使用define:[搜索短语]查找其定义）</li><li>related:（使用related:[URL]查找与特定网站类似的网站）</li><li>$（查找某价格范围内的商品）</li><li>AROUND(n)（写在两个搜索词之间，查找在同一句话或段落中提到这两个搜索词的页面，n表示两个词相距的最大距离，直接写n表示距离不设上限）</li><li>before/after:（筛选时间范围内的搜索结果）例如：复仇者联盟 after:2020-12-01</li><li>cache:（查看网页快照）例如：cache:qq.com</li><li>link:（搜索所有链接到某个URL地址的网页）最重要的用途：迅速判断一个网页的“热度”。</li></ul>]]></content>
    
    <summary type="html">
    
      Google搜索的语法，熟练使用可以提高搜索效率
    
    </summary>
    
    
    
      <category term="常用tips" scheme="https://xuanxiaoming.github.io/tags/%E5%B8%B8%E7%94%A8tips/"/>
    
  </entry>
  
  <entry>
    <title>playbook详解</title>
    <link href="https://xuanxiaoming.github.io/2022/01/18/playbook%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xuanxiaoming.github.io/2022/01/18/playbook%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-18T04:51:18.000Z</published>
    <updated>2022-05-05T04:17:47.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Playbook详解"><a href="#Playbook详解" class="headerlink" title="Playbook详解"></a>Playbook详解</h1><p>playbook由一个或多个“plays”组成。它的内容是一个以“plays”为元素的列表。</p><p>在ansible中，play的内容被称为tasks（任务）。在基本层次的应用中，一个任务是一个对ansible模块的调用。</p><p>通过playbook，可以编排步骤进行多机器的部署，比如在webservers组的所有机器上运行一定的步骤，然后在database server组运行一些步骤，最后回到webservers组，再运行一些步骤，诸如此类。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 例如</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">http_port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">max_clients</span><span class="token punctuation">:</span> <span class="token number">200</span>  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ensure apache is at the latest version    <span class="token key atrule">yum</span><span class="token punctuation">:</span> pkg=httpd state=latest  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> write the apache config file    <span class="token key atrule">template</span><span class="token punctuation">:</span> src=/srv/httpd.j2 dest=/etc/httpd.conf    <span class="token key atrule">notify</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> restart apache  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ensure apache is running    <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=started  <span class="token key atrule">handlers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart apache      <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=restarted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主机和用户"><a href="#主机和用户" class="headerlink" title="主机和用户"></a>主机和用户</h2><p>hosts行的内容是一个或多个组或主机的patterns，以逗号为分隔符；remote_user就是账户名（在Ansible 1.4以后才改为 remote_user。主要为了不跟user模块混淆，user 模块用于在远程系统上创建用户）</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 支持sudo执行命令</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> yourname  <span class="token key atrule">sudo</span><span class="token punctuation">:</span> yes<span class="token comment" spellcheck="true"># 也可以仅在一个task中使用sudo执行命令，而不是在整个play中使用sudo</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> yourname  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">service</span><span class="token punctuation">:</span> name=nginx state=started      <span class="token key atrule">sudo</span><span class="token punctuation">:</span> yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Tasks列表"><a href="#Tasks列表" class="headerlink" title="Tasks列表"></a>Tasks列表</h2><p>每一个play包含了一个task列表（任务列表）。一个task在其所对应的所有主机上执行完毕之后，下一个task才会执行。有一点需要明白的是，在一个play之中，所有hosts会获取相同的任务指令，这是play的一个目的所在，也就是会将所有选出的hosts映射上task。</p><p>每个task的目标在于执行一个moudle，通常是带有特定的参数来执行。在参数中可以使用变量（variables）。</p><p>modules具有“幂等”性，意思是如果你再一次地执行moudle，moudle只会执行必要的改动，只会改变需要改变的地方。所以重复多次执行playbook也很安全。</p><blockquote><p>为什么使用module而不是打包一套shell放在机器上运行？</p><p>答：为了幂等性，将tasks交给ansible控制，不至于多次执行tasks进行重复操作，从而降低风险。当然使用shell也有办法解决幂等性，但远不如这样更加直观。</p></blockquote><p>每一个task必须有一个名称name，这样在运行playbook时，从其输出的任务执行信息中可以很好的辨别出是属于哪一个task的。如果没有定义name，“action”的值将会用作输出信息中标记特定的task。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 基本的task的定义</span><span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> make sure apache is running    <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较特别的两个modudle是command和shell，它们不使用key=value格式的参数，而是这样：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> disable selinux    <span class="token key atrule">command</span><span class="token punctuation">:</span> /sbin/setenforce 0<span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run this command and ignore the result    <span class="token key atrule">shell</span><span class="token punctuation">:</span> /usr/bin/somecommand    <span class="token key atrule">ignore_errors</span><span class="token punctuation">:</span> <span class="token boolean important">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Action-Shorthand"><a href="#Action-Shorthand" class="headerlink" title="Action Shorthand"></a>Action Shorthand</h2><p>新版ansible更喜欢使用如下的格式列出modules：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">template</span><span class="token punctuation">:</span> src=templates/foo.j2 dest=/etc/foo.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Handlers-在发生改变时执行的操作"><a href="#Handlers-在发生改变时执行的操作" class="headerlink" title="Handlers: 在发生改变时执行的操作"></a>Handlers: 在发生改变时执行的操作</h2><p>module 具有”幂等”性,所以当远端系统被人改动时，可以重放playbooks达到恢复的目的。playbooks本身可以识别这种改动，并且有一个基本的event system（事件系统），可以响应这种改动。</p><p>（当发生改动时）‘notify’ actions会在playbook的每一个task结束时被触发，而且即使有多个不同的task通知改动的发生，‘notify’ actions只会被触发一次。</p><p>举例来说，比如多个resources指出因为一个配置文件被改动，所以apache需要重新启动，但是重新启动的操作只会被执行一次。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># ‘notify’ 下列出的即是handlers</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> template configuration file  <span class="token key atrule">template</span><span class="token punctuation">:</span> src=template.j2 dest=/etc/foo.conf  <span class="token key atrule">notify</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> restart memcached     <span class="token punctuation">-</span> restart apache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Handlers也是一些task的列表，通过名字来引用，它们和一般的task并没有什么区别。Handlers是由通知者进行notify, 如果没有被notify，handlers不会执行。不管有多少个通知者进行了notify，等到play中的所有task执行完成之后，handlers也只会被执行一次。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 这是一个handlers的示例:</span><span class="token key atrule">handlers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart memcached      <span class="token key atrule">service</span><span class="token punctuation">:</span>  name=memcached state=restarted    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart apache      <span class="token key atrule">service</span><span class="token punctuation">:</span> name=apache state=restarted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>handlers 最佳的应用场景是用来重启服务，或者触发系统重启操作。除此以外很少用到了。</p><p>handlers 会按照声明的顺序执行</p></blockquote><p>如果你想立即执行所有的handler命令，在1.2及以后的版本，你可以这样做:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 任何在排队等候的handlers会在执行到‘meta’部分时，优先执行</span><span class="token key atrule">tasks</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">shell</span><span class="token punctuation">:</span> some tasks go here   <span class="token punctuation">-</span> <span class="token key atrule">meta</span><span class="token punctuation">:</span> flush_handlers   <span class="token punctuation">-</span> <span class="token key atrule">shell</span><span class="token punctuation">:</span> some other tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行Playbook"><a href="#执行Playbook" class="headerlink" title="执行Playbook"></a>执行Playbook</h2><pre class="line-numbers language-shell"><code class="language-shell"># 运行10个并发的playbook> ansible-playbook playbook.yml -f 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Playbook基本结构"><a href="#Playbook基本结构" class="headerlink" title="Playbook基本结构"></a>Playbook基本结构</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># [···] 表示可选配置</span><span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span>vars<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span>  <span class="token key atrule">task</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>yum/template/service/<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>notify<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>    service<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      有关Ansible playbook的详细解释的精简版，有助于理清思路
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Ansible笔记</title>
    <link href="https://xuanxiaoming.github.io/2022/01/14/ansible%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2022/01/14/ansible%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-13T18:01:32.000Z</published>
    <updated>2022-05-05T04:17:38.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible笔记"><a href="#Ansible笔记" class="headerlink" title="Ansible笔记"></a>Ansible笔记</h1><h3 id="ansible连接时是使用ssh还是open-ssh"><a href="#ansible连接时是使用ssh还是open-ssh" class="headerlink" title="ansible连接时是使用ssh还是open-ssh"></a>ansible连接时是使用ssh还是open-ssh</h3><p>很明显是使用ssh，open-ssh只是包装了ssh的一个插件，本质上还是使用ssh</p><h3 id="inventory和ansible-cfg的有什么区别，作用是什么"><a href="#inventory和ansible-cfg的有什么区别，作用是什么" class="headerlink" title="inventory和ansible.cfg的有什么区别，作用是什么"></a>inventory和ansible.cfg的有什么区别，作用是什么</h3><p>inventory中文含义为库存，也叫物品清单。顾名思义是用于填写机器列表的地方，在文件 <code>/etc/ansible/host</code> 中根据语法填入接受控制机管理的机器ip即可</p><p>ansible.cfg为ansible的配置文件。配置文件可以修改很多东西，比如inventory文件指向、默认用户名密码等等，绝大多数情况下仅配置inventory就足够了</p><pre class="line-numbers language-shell"><code class="language-shell">> ansible --versionansible 2.9.6  config file = /etc/ansible/ansible.cfg  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']  ansible python module location = /usr/lib/python3/dist-packages/ansible  executable location = /usr/bin/ansible  python version = 3.8.10 (default, Nov 26 2021, 20:14:08) [GCC 9.3.0]> cat /etc/ansible/ansible.cfg | less[defaults]# some basic default values...#inventory      = /etc/ansible/hosts#library        = /usr/share/my_modules/#module_utils   = /usr/share/my_module_utils/#remote_tmp     = ~/.ansible/tmp#local_tmp      = ~/.ansible/tmp#plugin_filters_cfg = /etc/ansible/plugin_filters.yml#forks          = 5#poll_interval  = 15#sudo_user      = root#ask_sudo_pass = True#ask_pass      = True#transport      = smart#remote_port    = 22#module_lang    = C#module_set_locale = False......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ssh配置提示-sshd-config-line-36-Deprecated-option-RSAAuthentication"><a href="#ssh配置提示-sshd-config-line-36-Deprecated-option-RSAAuthentication" class="headerlink" title="ssh配置提示 sshd_config line 36: Deprecated option RSAAuthentication"></a>ssh配置提示 sshd_config line 36: Deprecated option RSAAuthentication</h3><p>RSAAuthentication （rsa认证）是只支持第1代ssh通讯协议使用的配置项，在CentOS7.4中被废除了，而且前面提到过CentOS7开始预设使用第二代通讯协议，在CentOS7.4中没有找到指定协议版本的配置行，个人猜测是CentOS7.4全面抛弃第1代协议。</p><p>第2代ssh通讯协议的密钥验证选项是<code>#PubkeyAuthentication yes</code></p><p>这个选项默认是注释掉的，并且是默认开启的，因此我们在使用第二代ssh通讯协议时不需要再去纠结 RSAAuthentication 选项了，在CentOS7.4中其强行添加 RSAAuthentication 配置会触发系统对它的废除提示。</p><pre class="line-numbers language-log"><code class="language-log">reprocess config line 38: Deprecated option RSAAuthentication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改ansible配置文件后，不需要重启"><a href="#修改ansible配置文件后，不需要重启" class="headerlink" title="修改ansible配置文件后，不需要重启"></a>修改ansible配置文件后，不需要重启</h3><p>ansible是一个可执行程序，不是服务。故修改任何参数都将在下一次运行中体现出来，不需要重启，也无方法重启。</p><h3 id="后续添加多台机器如何配置ansible"><a href="#后续添加多台机器如何配置ansible" class="headerlink" title="后续添加多台机器如何配置ansible"></a>后续添加多台机器如何配置ansible</h3><p>使用动态inventory</p>]]></content>
    
    <summary type="html">
    
      有关Ansible配置和使用中发生问题记录
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/12/13/docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/12/13/docker%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-13T07:34:51.000Z</published>
    <updated>2022-05-05T04:16:39.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker笔记"><a href="#Docker笔记" class="headerlink" title="Docker笔记"></a>Docker笔记</h1><h4 id="检索docker容器IP"><a href="#检索docker容器IP" class="headerlink" title="检索docker容器IP"></a>检索docker容器IP</h4><pre class="line-numbers language-shell"><code class="language-shell"># 为了回避前端vue页面渲染标记，请自行将 [[ 替换为 {{，反之同理docker inspect -f '[[range .NetworkSettings.Networks]][[.IPAddress]][[end]]' [CONTAINER ID]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="docker可视化管理容器"><a href="#docker可视化管理容器" class="headerlink" title="docker可视化管理容器"></a>docker可视化管理容器</h4><p>使用portainer-ce，ce通常是指官方维护的非商业版</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /Users/xuan/portainer_data:/data portainer/portainer-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="docker挂载卷的总结和避坑"><a href="#docker挂载卷的总结和避坑" class="headerlink" title="docker挂载卷的总结和避坑"></a>docker挂载卷的总结和避坑</h4><p>docker 有几种方式都可以挂载卷，实现与宿主机共享文件。但是我在网上搜索了很久也没有遇到讲解关于在dockerfile中使用volume实现docker run -v那种自定义挂载文件夹的方式，找了很长时间才找到问题所在。</p><p>正常使用挂载，假设我想将桌面的demo文件夹挂载到ubuntu中的share文件夹，我可以这么写<code>docker run -v /Desktop/demo:/share ubuntu</code>。但是这样在dockerfile中是不允许的，dockerfile文件的目的是为了编撰镜像属性，而不是交互属性。交互属性应该是在镜像构建为容器时定义的。所以如果有交互方面的需求可以使用docker compose去实现。</p><p>实际上容器内部的文件夹有三种情况：</p><ol><li><p>没有指定VOLUME，也没有指定-v，这种是普通文件夹</p></li><li><p>指定了VOLUME，ENTRYPOINT没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改</p></li><li><p>指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改</p></li></ol><h4 id="dockerfile中-ENTRYPOINT-和-CMD-的区别"><a href="#dockerfile中-ENTRYPOINT-和-CMD-的区别" class="headerlink" title="dockerfile中 ENTRYPOINT 和 CMD 的区别"></a>dockerfile中 ENTRYPOINT 和 CMD 的区别</h4><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># dockerfile中写CMD echo "hello world"# 运行容器时docker run -it xxx /bin/bash# 会直接打开交互命令行，CMD内容被直接忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># dockerfile中写ENTRYPOINT echo "hello world"# 运行容器时docker run -it xxx /bin/bash# 会直接忽略/bin/bash，输出hello world# 只有在运行容器指令后加--entrypoint，才能覆盖dockerfile中的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常建议使用的方式是，CMD和ENTRYPOINT结合使用，并使用Exec格式编写，用CMD为ENTRYPOINT添加参数。</p>]]></content>
    
    <summary type="html">
    
      docker相关知识点和排坑记录
    
    </summary>
    
    
    
      <category term="docker" scheme="https://xuanxiaoming.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>linux三剑客</title>
    <link href="https://xuanxiaoming.github.io/2021/12/10/linux%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>https://xuanxiaoming.github.io/2021/12/10/linux%E4%B8%89%E5%89%91%E5%AE%A2/</id>
    <published>2021-12-10T07:29:38.000Z</published>
    <updated>2022-05-30T03:05:09.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>grep 命令用于查找文件里符合条件的字符串。</p><p>使用格式 <code>grep [command] &quot;待查文本&quot; &quot;查询地址（支持文件名通配符）&quot;</code></p><p>其中command可以使用 <code>-E</code> 使待查文本支持正则表达式</p><pre class="line-numbers language-shell"><code class="language-shell"># 例如：> grep test *file # 含义是在当前路径中所有文件名后缀为file的文件中查找‘test’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>-Eo</code> 可以只输出正则表达式匹配到的子字符串</p><p>比如在docker compose中启动多台容器，但我现在要获取除了主控制容器外的全部容器ip，我就可以这么写：</p><pre class="line-numbers language-shell"><code class="language-shell"># 为了回避前端vue页面渲染标记，请自行将 [[ 替换为 {{，反之同理docker network inspect -f "[[json .Containers]]" [网段docker network id] | jq '.[] | select(.Name != "xcontroller") | .IPv4Address' | grep -Eo '[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>使用了jq工具（需要额外安装 <code>apt install jq</code>）用于解析json</p></blockquote><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>sed命令用于对文件流进行编辑。意思就是说可以编辑文件，但编辑完不会保存到文件。</p><p>如果使用 <code>sed -i</code> 可以直接保存编辑文件内容。</p><p><code>$</code> 表示末尾，如想在末尾添加文本，可以 <code>sed -i &#39;$a [文本]&#39; [文件地址]</code> ，如果在 <code>a</code> 的前面不标明行号，则代表每行后都追加</p><p>行号写 <code>2,5</code> 不是第2行和第5行的意思，是2-5行</p><pre class="line-numbers language-shell"><code class="language-shell">sed '1i 添加的内容' file  #这是在第一行前添加字符串sed '$i 添加的内容' file  #这是在最后一行行前添加字符串sed '$a添加的内容' file   #这是在最后一行行后添加字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>]]></content>
    
    <summary type="html">
    
      关于linux上最常用的三个工具grep、sed、awk的笔记
    
    </summary>
    
    
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>m1芯片安装docker-mysql</title>
    <link href="https://xuanxiaoming.github.io/2021/11/15/m1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85docker-mysql/"/>
    <id>https://xuanxiaoming.github.io/2021/11/15/m1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85docker-mysql/</id>
    <published>2021-11-15T09:08:57.000Z</published>
    <updated>2023-04-27T09:00:48.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="m1芯片安装docker-mysql"><a href="#m1芯片安装docker-mysql" class="headerlink" title="m1芯片安装docker-mysql"></a>m1芯片安装docker-mysql</h2><p>自己平时是不喜欢直接在机器上安装mysql的，因为碎片文件比较多，删除mysql的时候会非常麻烦，得不厌其烦的寻找并删除碎片文件。直到我遇到了docker，我才觉得找到了答案，直接在docker上启动一个mysql服务，用可视化工具做远程连接就好，删除也没有负担，随时随地都可以重新准备就绪。</p><p>但是最近我在新电脑上启动docker-mysql时发现docker官方容器并不支持apple m1芯片，找了很长时间才找到一个由mysql官方维护的容器是支持的，于是就开始尝试使用这个容器。</p><p>在使用过程中，我发现一个问题就是我的DataGrid怎么也连不上mysql服务，一直提示 <code>[HY000][1130] null, message from server: &quot;Host &#39;172.17.0.1&#39; is not allowed to connect to this MySQL server&quot;.</code>。研究了很长时间，发现原因是该容器是mysql-server，可以理解为运行着mysql的服务器，所以本地连接的时候相当于远程访问，也就是说需要进容器内打开mysql的远程登录，并授予用户远程登录权限。</p><p>具体操作如下：</p><ol><li><p>启动mysql-server容器（可以加-v将宿主机卷空间挂载进去，用于备份数据库）</p><pre class="line-numbers language-shell"><code class="language-shell">docker run --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql/mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用改表法为用户增加访问权限docker exec进容器内，找到mysql库下的user表，将其hosts从localhost改成%或远程主机的IP（我这里是个人机器上使用就改root用户，具体请酌情考虑）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>prootmysql<span class="token operator">></span> <span class="token keyword">use</span> mysql<span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> host<span class="token punctuation">,</span><span class="token keyword">user</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> host<span class="token operator">=</span><span class="token string">"%"</span> <span class="token keyword">where</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> host<span class="token punctuation">,</span><span class="token keyword">user</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上述内容修改完后，就可以退出容器里，最后重启容器即可</p><pre class="line-numbers language-shell"><code class="language-shell">docker restart mysql-server;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>以上步骤都做完后，即可使用可视化工具远程访问mysql服务。最后需要注意的一点是，远程访问最好设置 <code>useSSL=true</code>，打开安全传输。</p>]]></content>
    
    <summary type="html">
    
      记录一下安装docker-mysql的过程
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-02T01:35:47.000Z</published>
    <updated>2023-04-27T08:30:21.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><ol><li><p><strong>第一范式(确保每列保持原子性)</strong></p><p> 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p></li><li><p><strong>第二范式(确保表中的每列都和主键相关)</strong></p><p> 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p> 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。</p><p> 所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。</p></li><li><p><strong>第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></p><p> 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p> 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p></li></ol><br><h1 id="数据库事务的四个特性"><a href="#数据库事务的四个特性" class="headerlink" title="数据库事务的四个特性"></a>数据库事务的四个特性</h1><p>事务具有四个特性:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。这四个特性简称为ACID原则。</p><ol><li><p><strong>原子性</strong></p><p> 事务必须是原子工作单元,事务中的操作要么全部执行,要么全都不执行,不能只完成部分操作。原子性在数据库系统中由恢复机制来实现。</p></li><li><p><strong>一致性</strong></p><p> 事务开始之前,数据库处于一致性的状态;事务结束后,数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如,在银行转账中,用户可以定义转账前后两个账户金额之和保持不变。</p></li><li><p><strong>隔离性</strong></p><p> 系统必须保证事务不受其他并发执行事务的影响,即当多个事务同时运行时,各事务之间相互隔离,不可互相干扰。事务查看数据时数据所处的状态,要么是另一个并发事务修改它之前的状态,要么是另一个并发事务修改它之后的状态,事务不会查看中间状态的数据。隔离性通过系统的并发控制机制实现。</p></li><li><p><strong>持久性</strong></p><p> 一个已完成的事务对数据所做的任何变动在系统中是永久有效的,即使该事务产生的修改不正确,错误也将一直保持。持久性通过恢复机制实现,发生故障时,可以通过日志等手段恢复数据库信息。</p></li></ol><br><h1 id="数据库事务的作用"><a href="#数据库事务的作用" class="headerlink" title="数据库事务的作用"></a>数据库事务的作用</h1><p>当我们需要批量执行sql语句修改多条数据时，为了确保数据的一致性（比如张三给李四转账100元，张三的金额-100，李四金额+100），必须加入事务的使用用以在完整且正确执行完所有sql操作后，再提交对数据的修改。</p><p>假设当执行完第一条sql后突然断电引发操作异常，在没有执行commit之前，数据均不会修改。</p><br><h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><p>主要有：<strong>表级锁</strong>和<strong>行级锁</strong></p><ol><li><p>读锁</p><p> 可以并发读，但不可以并发写。读锁期间，没释放锁前不能进行写操作。</p><pre class="line-numbers language-SQL"><code class="language-SQL"> lock table [TableName] read; unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>写锁</p><pre class="line-numbers language-SQL"><code class="language-SQL"> lock table [TableName] write; unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h1 id="常用数据库引擎的区别"><a href="#常用数据库引擎的区别" class="headerlink" title="常用数据库引擎的区别"></a>常用数据库引擎的区别</h1><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202304271626364.png" alt="常用数据库引擎的区别"></p><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。</p><p>主要特性：</p><ol><li><p>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似<strong>Oracle</strong>的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合。</p></li><li><p>InnoDB是为处理巨<strong>大数据</strong>量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的。</p></li><li><p>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</p></li><li><p>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件。</p></li></ol><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。</p><p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p><p>主要特性：</p><ol><li><p>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</p></li><li><p>当把删除、更新和插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成。</p></li><li><p>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16。</p></li><li><p>BLOB和TEXT列可以被索引。</p></li><li><p>NULL被允许在索引的列中，这个值占每个键的0~1个字节。</p></li><li><p>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快。</p></li><li><p>可以把数据文件和索引文件放在不同目录。</p></li><li><p>每个字符列可以有不同的字符集。</p></li><li><p>有VARCHAR的表可以固定或动态记录长度。VARCHAR和CHAR列可以多达64KB。</p></li></ol><h2 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h2><p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。</p><p>主要特性：</p><ol><li><p>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度。</p></li><li><p>MEMORY存储引擎执行HASH和BTREE缩影。</p></li><li><p>可以在一个MEMORY表中有非唯一键值。</p></li><li><p>MEMORY表使用一个固定的记录长度格式。</p></li><li><p>MEMORY不支持BLOB或TEXT列。</p></li><li><p>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引。</p></li><li><p>MEMORY表在所有客户端之间共享。</p></li><li><p>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</p></li></ol><h2 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h2><p>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive。</p>]]></content>
    
    <summary type="html">
    
      数据相关知识
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/09/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/09/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-01T01:38:14.000Z</published>
    <updated>2022-05-30T03:03:54.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Golang学习笔记"><a href="#Golang学习笔记" class="headerlink" title="Golang学习笔记"></a>Golang学习笔记</h2><h3 id="map清空的问题"><a href="#map清空的问题" class="headerlink" title="map清空的问题"></a>map清空的问题</h3><p>Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p><h3 id="并发安全的map"><a href="#并发安全的map" class="headerlink" title="并发安全的map"></a>并发安全的map</h3><p>Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p>sync.Map 有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li></ul><p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h3 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h3><ol><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化</li></ol><p>make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><h3 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h3><ul><li><p><strong>数组</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// value := [数据长度]类型 {}</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 声明并且赋值</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 声明未赋值</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组类型的值（以下简称数组）的长度是固定的数组的长度在声明它的时候就必须给定，并且在之后不会再改变。可以说，数组的长度是其类型的一部分（数组的容量永远等于其长度，都是不可变的）</p></li><li><p><strong>切片</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// value := []类型 {}</span><span class="token comment" spellcheck="true">// 创建长度容量都为0的切片</span>value <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// []string{"1"} 长度容量为1的切片</span>value <span class="token operator">:=</span><span class="token function">append</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 数据转切片</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">}</span>slice <span class="token operator">:=</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 创建长度容量为1的切片</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 创建长度为1，容量为2的切片</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片类型的值是可变长的。而切片的类型字面量中只有其元素的类型，而没有其长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减少。在每一个切片的底层数据结构中，会包含一个数组，可以被叫做底层数据，而切片就是对底层数组的引用，故而<strong>切片类型属于引用类型</strong>。</p></li></ul><blockquote><p>一个切片无法容纳更多的元素时，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。<br>但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。<br>只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。</p></blockquote><h3 id="import-导包前的下划线“-”含义"><a href="#import-导包前的下划线“-”含义" class="headerlink" title="import 导包前的下划线“_”含义"></a>import 导包前的下划线“_”含义</h3><p>import 下划线（如：import _ github/demo）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。</p><h3 id="sql-Open-中数据库连接串格式"><a href="#sql-Open-中数据库连接串格式" class="headerlink" title="sql.Open()中数据库连接串格式"></a>sql.Open()中数据库连接串格式</h3><p>sql.Open()中的数据库连接串格式为：<code>&quot;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&quot;</code></p><h3 id="Go-项目中是否应把-go-sum-放到-Git-版本库里？"><a href="#Go-项目中是否应把-go-sum-放到-Git-版本库里？" class="headerlink" title="Go 项目中是否应把 go.sum 放到 Git 版本库里？"></a>Go 项目中是否应把 go.sum 放到 Git 版本库里？</h3><p>官方的建议是要将 <code>go.sum</code> 和 <code>go.mod</code> 两个文件一起提交到代码库中，这样才能保证项目依赖包版本的一致，同时保证 Build 的一致性。</p><h3 id="Go语言无范型，如何创建多对象json？"><a href="#Go语言无范型，如何创建多对象json？" class="headerlink" title="Go语言无范型，如何创建多对象json？"></a>Go语言无范型，如何创建多对象json？</h3><p>go语言中struct创建的类型，可以做对象数组</p><p>例如有一个json长这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token property">"A"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"B"</span><span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        <span class="token property">"a"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"b"</span><span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析后直接使用[]User去接收</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ……<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里有一篇文章总结的很详细：<code>https://juejin.cn/post/6844903891344048141</code></p><h3 id="Go语言date类型，时间操作"><a href="#Go语言date类型，时间操作" class="headerlink" title="Go语言date类型，时间操作"></a>Go语言date类型，时间操作</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 获取当前时间</span>dateTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 年</span>year <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 月</span>month <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 日</span>day <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 小时</span>hour <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 分钟</span>minute <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 秒</span>second <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 纳秒</span>nanosecond <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Nanosecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 时间戳，计算到秒</span>timeUnix <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳，计算到纳秒</span>timeUnixNano <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳格式化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳转为go格式的时间</span><span class="token keyword">var</span> timeUnix <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">1562555859</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span>timeUnix<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 获取今天23:59:59秒的时间戳</span>currentTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>endTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> currentTime<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           currentTime<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> currentTime<span class="token punctuation">.</span><span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>endTime<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>endTime<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006/01/02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 计算两个时间戳相距多少时间，后面换算成各种单位</span>afterTime<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseDuration</span><span class="token punctuation">(</span><span class="token string">"1h"</span><span class="token punctuation">)</span>result <span class="token operator">:=</span> currentTime<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>afterTime<span class="token punctuation">)</span>beforeTime<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseDuration</span><span class="token punctuation">(</span><span class="token string">"-1h"</span><span class="token punctuation">)</span>result2 <span class="token operator">:=</span> currentTime<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>beforeTime<span class="token punctuation">)</span>m <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 分钟 \n"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">Minutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>h <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 小时 \n"</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span><span class="token function">Hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>d <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 天 \n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 判断一个时间相比另外一个时间过去了多久</span>startTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"离现在过去了："</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Go语言-空接口"><a href="#Go语言-空接口" class="headerlink" title="Go语言 空接口"></a>Go语言 空接口</h3><p>go语言中所有的类型都实现了空接口，相当于java中的Object，因此空接口可以存储任意类型的数值。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul><li>并行（parallelism）：指在同一时刻，有多条指令在多个处理器上同时执行。</li><li>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，得到在宏观上有多个进程同时执行的效果，但在微观上并不是同时执行，只是把时间片分成了若干段，使得多个进程快速交替执行。</li></ul><h3 id="什么是TPS，什么是QPS，区别是什么？"><a href="#什么是TPS，什么是QPS，区别是什么？" class="headerlink" title="什么是TPS，什么是QPS，区别是什么？"></a>什么是TPS，什么是QPS，区别是什么？</h3><ul><li>TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问（业务TPS = CAPS × 每个呼叫平均TPS）。TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</li><li>QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</li></ul><h3 id="Go语言-CSP模型-channel-管道"><a href="#Go语言-CSP模型-channel-管道" class="headerlink" title="Go语言 CSP模型 channel(管道)"></a>Go语言 CSP模型 channel(管道)</h3><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做 <strong>通信顺序进程，是一种并发编程模型</strong> ，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p><p>Golang 就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有完全实现了CSP模型的所有理论，仅仅是借用了 process和channel这两个概念。process是在go语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。</p><p>Go语言的CSP模型是由协程Goroutine与通道Channel实现：</p><ul><li>Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。</li><li>通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。</li></ul><blockquote><p><strong>核心思想：不要通过共享内存来通信，而要通过通信来实现内存共享。</strong></p></blockquote><p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><h3 id="反射的意义，可以应用在什么地方？"><a href="#反射的意义，可以应用在什么地方？" class="headerlink" title="反射的意义，可以应用在什么地方？"></a>反射的意义，可以应用在什么地方？</h3><p>反射本质上不是一个编程语言必须具备的特性。<br>反射的意义在于将本应该对程序员透明的机制，暴露给程序员，使得我们有能力去操纵它，让它能够更灵活地完成我们的工作。<strong>即动态修补程序代码。</strong><br>反射这种东西，确实破坏了封装的初衷，但他们两者之间并不是绝对的对立。想一想，我们封装、隐藏细节、建立抽象屏障，无外乎都是为了降低程序的复杂度——这是工程上的折衷，因为面对复杂的程序结构，人脑太不够用了。在大量的实践中我们发现，我们抽象出来的通用模式并不是绝对的，很多问题在它构建的框架之下解决起来就是非常麻烦，所以需要反射这种机制，动态的、灵活的修补代码，使之为我们的实际业务需求建立服务。<br>所以有了反射这么一手，把很多难以预测的问题留到运行时，动态地去考虑去解决。这也就使得我们在走投无路时，还可以有一道后门开着让我们大摇大摆地进入。</p><h3 id="Go语言-函数名称前的变量含义"><a href="#Go语言-函数名称前的变量含义" class="headerlink" title="Go语言 函数名称前的变量含义"></a>Go语言 函数名称前的变量含义</h3><p>在接触到go之前，我认为函数和方法只是同一个东西的两个名字而已（在我熟悉的c/c++，python，java中没有明显的区别），但是在golang中者完全是两个不同的东西。官方的解释是，方法是包含了接收者的函数。golang语言中函数和方法是两种不同的概念</p><p>首先函数的格式是固定的，func ＋ 函数名 ＋ 参数 ＋ 返回值（可选） ＋ 函数体。</p><p>方法和函数的区别，方法在func关键字后是接收者而不是函数名，接收者可以是自己定义的一个类型，这个类型可以是struct，interface，甚至我们可以重定义基本数据类型。我们可以给他一些我们想要的方法来满足我们的实际工程中的需求，这里我们要注意一个细节，接收者是指针和非指针的区别，我们可以看到当接收者为指针式，我们可以通过方法改变该接收者的属性，但是非指针类型缺做不到。</p><p>假设将一个结构体看作是一个类，那么方法（有接收者的）可以看成是该类的成员函数</p><h3 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h3><ol><li>反射可以将接口类型变量转换为反射类型变量</li><li>反射可以将反射类型变量转换为接口类型</li><li>想要使用反射来修改变量的值，其值必须是可写的（CanSet）。这个值必须满足两个条件：<ul><li>变量可以被寻址（CanAddr）</li><li>变量可导出（结构体字段名首字母需大写，不能为匿名字段）</li></ul></li></ol><blockquote><p>反射的性能极差，能不用反射尽量不用</p></blockquote><h3 id="Go语言代码测试分类"><a href="#Go语言代码测试分类" class="headerlink" title="Go语言代码测试分类"></a>Go语言代码测试分类</h3><ul><li>单元测试<br>测试函数的功能性问题<br>使用方式：在函数名前加Test前缀，传入(t *testing.T)</li><li>基准测试<br>分析代码存在的CPU性能和内存分配问题<br>使用方法：在函数名前加Benchmark前缀，传入(t *testing.B)</li><li>覆盖率测试<br>统计通过运行程序包的测试有多少代码得到了执行<br>使用方法：go test -cover XX.go</li></ul><h3 id="Http、Socket、WebSocket之间联系与区别"><a href="#Http、Socket、WebSocket之间联系与区别" class="headerlink" title="Http、Socket、WebSocket之间联系与区别"></a>Http、Socket、WebSocket之间联系与区别</h3><p><strong>把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。</strong><br><strong>HTTP协议，有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。</strong><br><strong>WebSocket协议，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</strong></p><ul><li><p>Http协议：简单的对象访问协议，对应于应用层。Http协议是基于TCP链接的</p></li><li><p>tcp协议：对应于传输层</p></li><li><p>ip协议：对应与网络层</p><blockquote><p>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而Http是应用层协议，主要解决如何包装数据。<br>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></blockquote></li><li><p>HTTP连接：http连接就是所谓的短连接，及客户端向服务器发送一次请求，服务器端相应后连接即会断掉。</p></li><li><p>Socket连接：socket连接及时所谓的长连接，理论上客户端和服务端一旦建立连接，则不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该链接已释放网络资源。所以当一个socket连接中没有数据的传输，那么为了位置连续的连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。</p></li></ul><h3 id="Go语言实现多态"><a href="#Go语言实现多态" class="headerlink" title="Go语言实现多态"></a>Go语言实现多态</h3><ol><li>创建公共接口</li><li>使用多个方法继承接口，传入参数为不同的结构体</li><li>调用时会根据传入参数的不同的结构体对象，分别调用不同的方法（实现多态）</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 公共接口</span><span class="token keyword">type</span> Mammal <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 不同的结构体对象</span><span class="token keyword">type</span> Dog <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Cat <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Human <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d Dog<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"woof"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"meow"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Human<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"speak"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 根据传入参数不同，调用不同的方法，实现多态</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> m Mammal    m <span class="token operator">=</span> Dog<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> Cat<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> Human<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3>]]></content>
    
    <summary type="html">
    
      go语言的学习笔记和问题思考
    
    </summary>
    
    
    
      <category term="golang" scheme="https://xuanxiaoming.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密登录</title>
    <link href="https://xuanxiaoming.github.io/2020/07/10/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <id>https://xuanxiaoming.github.io/2020/07/10/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</id>
    <published>2020-07-10T04:19:26.000Z</published>
    <updated>2022-05-30T03:04:39.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h1><ol><li><p>在系统上安装ssh后，生成秘钥</p><pre class="line-numbers language-shell"><code class="language-shell">> ssh-keygen -t rsa -C "info"-t 指定加密算法-C 在密文尾部加标记信息 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>将公钥发布到待免密登录的机器上</p><pre class="line-numbers language-shell"><code class="language-shell">> cd ~/.ssh/# 有两种方式发送公钥到远程机器上 > ssh-copy-id -i [本地公钥文件id_rsa.pub路径] 用户名@IP# 这样一部就可以将公钥写到远程机器的 /.ssh/authorized_keys 中，缺点是默认22端口，不可更改> scp ~/.ssh/id_rsa.pub 用户名@IP:.ssh/id_rsa_remote.pub> cat id_rsa_remote.pub >> authorized_keys# 这种方式既可以设置端口，也可以用于对方机器非root用户的情况（需要密码）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell"># 在我们想使用脚本自动完成秘钥发布工作时，可以使用sshpass解决人机交互问题> sshpass -p '密码' ssh-copy-id "-o StrictHostKeyChecking=no" 用户名@IP# sshpass会为你的首次连接自动填充密码# 同时使用"-o StrictHostKeyChecking=no"解决输入密码后的网络校验工作，避免首次登录输入yes# 这样就解决了两步人机交互问题，实现自动化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li><p>B机器上有A机器的公钥，则A可以免密登录到B，不要记反了。</p></li><li><p>可以使用 <code>passwd 用户名</code> 更改用户的密码</p></li><li><p>需要在sshd的配置文件 <code>/etc/ssh/sshd_config</code> 中增加 <code>PermitRootLogin yes</code> 和 <code>PubkeyAuthentication yes</code>，用于打开root用户远程访问和秘钥验证登录</p></li></ol></blockquote></li></ol><ol start="3"><li><p>ssh连接到到机器上</p><pre><code>配置完成后，使用 `ssh 用户名@IP` 连接远程机器，首次连接会询问是否继续，输入yes，会在本地生成known_hosts文件用于记录已访问机器</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      linux免密登录的配置方式
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建填坑记录 二</title>
    <link href="https://xuanxiaoming.github.io/2020/03/04/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BA%8C/"/>
    <id>https://xuanxiaoming.github.io/2020/03/04/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BA%8C/</id>
    <published>2020-03-04T11:26:52.000Z</published>
    <updated>2022-05-27T21:34:07.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在博客的维护和更新过程中我遇到了很多琐碎的小问题，我决定新建立一篇文章，用于记录这些小问题和解决办法。<br>由于内容过于琐碎，所以我就直接列表记录了，他们之间并无逻辑关联。 </p></blockquote><br> <blockquote><p><font style="font-size:120%"> <strong>修改首页左侧导航栏列表循序</strong>  </font></p></blockquote><p>我发现主题的创建者只将归档(archive)这个页面单独做了处理，而我新加入的页面直接是对<code>site.pages</code>这个变量做了一个遍历，这导致我无法控制列表的排布，显得很乱，所以我最终的解决方案是直接将中间这段代码注释掉，将<code>&lt;a&gt;</code>标签内容写了进去，很简单粗暴的解决办法。  </p><pre><code>&lt;% if (theme.archives) { %&gt;&lt;a class=&quot;a-block no-tint nav-link-item &lt;%= is_current(&#39;archives&#39;) &amp;&amp; &#39;active&#39; %&gt;&quot; href=&quot;&lt;%= config.root + &quot;archives&quot; %&gt;&quot;&gt;    &lt;%= __(&#39;Archive&#39;) %&gt;&lt;/a&gt;&lt;% } %&gt;&lt;% if(site.pages){ %&gt;&lt;% site.pages.each(function (page){ %&gt;&lt;a class=&quot;a-block nav-link-item &lt;%= is_current(page.path) &amp;&amp; &#39;active&#39; %&gt;&quot; href=&quot;&lt;%= config.root + page.path %&gt;&quot;&gt;    &lt;%= page.title %&gt;&lt;/a&gt;&lt;% });} %&gt;&lt;% if (theme.rss) { %&gt;&lt;a class=&quot;a-block no-tint nav-link-item&quot; href=&quot;&lt;%= config.root + theme.rss %&gt;&quot;&gt;    &lt;%= __(&#39;RSS&#39;) %&gt;&lt;/a&gt;&lt;% } %&gt;  </code></pre><p>之后我又发现PC网页上的导航顺序没问题了，但是移动端的页面列表循序还是乱的，在仔细核查了主题作者的代码后，我终于在另一个文件中找到了，为了方便以后修改，我在此记录一下。 </p><pre><code>side_nav.ejs —— PC端的导航模块single_column_head.ejs —— 移动端的导航模块  </code></pre><br><blockquote><p><font style="font-size:120%"> <strong>SSL证书申请，配置强制跳转https</strong> </font>  </p></blockquote><p>这块是这样的， 我上次在阿里云注册https的时候， 阿里云那边出了bug， 就是SSL证书那块我一直申请不下来（阿里云的免费SSL）， 点不动那个按钮， 所以就一直用http访问到现在， 这次我上阿里云的控制面板试探性的点了一下，发现这个可以申请了， 然后我就把https给配置好了。 为什么我一直要配置https呢，因为现在的浏览器，比如Safari、Chrome，他们都会把非https的连接标记为非安全连接，实际上你作为建站人你自己是知道的，就是一个博客而已什么也没干，但是这块就是让人很憋屈。  </p><p>配置完这个https之后，我平时访问的时候，我发现还是会有http的访问，起初我以为是浏览器缓存的问题，但是并不是这样，后来我改了很多东西，甚至怀疑到了CNAME这个文件上，现在想想真是可笑至极。最后这个问题我在阿里云的全站加速的配置里找到了。如图所示，修改下强制跳转就行。  </p><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280533856.png" alt="强制跳转">  </p><br><blockquote><p><font style="font-size:120%"> <strong>CNAME文件与hexo忽略文件</strong> </font>  </p></blockquote><p>这个文件是做什么的，我就不说了，直接网上查一下就有。它在github中的作用是告诉gitHub page服务你的自定义域名是什么，顾名思义，这个文件里面填的就是你的域名，没别的了。</p><p>在和hexo连用的时候我发现一个问题，当我执行<code>hexo clean</code>命令后，会将public文件夹下的文件全部删除，包括CNAME。这时候有两种解决办法，一是将CNAME文件放到source文件夹下，这样在<code>hexo g</code>后会将该文件原封不动copy到public文件夹下，避免了clean的删除。二是在hexo的全局配置文件里加入忽略文件（hexo会默认忽略“.”开头的和隐藏的文件）</p><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280532219.png" alt="hexoConfig">  </p><p>举例：  </p><pre><code># Include/Exclude Files/Foldersinclude:    - &quot;.nojekyll&quot;    # 包括 &#39;source/css/_typing.css&#39;    - &quot;css/_typing.css&quot;    # 包括 &#39;source/_css/&#39; 中的任何文件，但不包括子目录及其其中的文件。    - &quot;_css/*&quot;    # 包含 &#39;source/_css/&#39; 中的任何文件和子目录下的任何文件    - &quot;_css/**/*&quot;exclude:    # 不包括 &#39;source/js/test.js&#39;    - &quot;js/test.js&quot;    # 不包括 &#39;source/js/&#39; 中的文件、但包括子目录下的所有目录和文件    - &quot;js/*&quot;    # 不包括 &#39;source/js/&#39; 中的文件和子目录下的任何文件    - &quot;js/**/*&quot;    # 不包括 &#39;source/js/&#39; 目录下的所有文件名以 &#39;test&#39; 开头的文件，但包括其它文件和子目录下的单文件    - &quot;js/test*&quot;    # 不包括 &#39;source/js/&#39; 及其子目录中任何以 &#39;test&#39; 开头的文件    - &quot;js/**/test*&quot;    # 不要用 exclude 来忽略 &#39;source/_posts/&#39; 中的文件。你应该使用 &#39;skip_render&#39;，或者在要忽略的文件的文件名之前加一个下划线 &#39;_&#39;    # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。ignore:    # Ignore any folder named &#39;foo&#39;.    - &quot;**/foo&quot;    # Ignore &#39;foo&#39; folder in &#39;themes/&#39; only.    - &quot;**/themes/*/foo&quot;    # Same as above, but applies to every subfolders of &#39;themes/&#39;.    - &quot;**/themes/**/foo&quot;</code></pre><p> 我用的是第一种方法解决的，第二种方法我没试，不过官方文档里都写了，所以也是一种合格的解决办法。</p><br><blockquote><p><font style="font-size:120%"> <strong>创建标签页</strong> </font>  </p></blockquote><p>主题作者只写了按时间归档的页面，标签页并没有写，甚至在使用文档里也没有说明（这个说明文档非常的简陋，issue里面一片哀嚎），但是hexo是自己支持标签分类的，我们只需要稍加配置一下即可。</p><p><a href="https://github.com/SumiMakito/hexo-theme-Journal/issues/20#issuecomment-551090136" target="_blank" rel="noopener">参考这篇issue里面AmazingRise的回答</a>：  </p><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280533025.png" alt="标签页配置">  </p><br><blockquote><p><font style="font-size:120%"> <strong>SEO优化</strong> </font>  </p></blockquote><p>参考这篇博文 –&gt; <a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a>  </p><p>说的很详细，我就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在博客的维护和更新过程中我遇到了很多琐碎的小问题，我决定新建立一篇文章，用于记录这些小问题和解决办法。&lt;br&gt;由于内容过于琐碎，所以我就直接列表记录了，他们之间并无逻辑关联。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt; 

&lt;blockquot
      
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建填坑记录</title>
    <link href="https://xuanxiaoming.github.io/2020/01/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://xuanxiaoming.github.io/2020/01/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-01-12T16:59:19.000Z</published>
    <updated>2022-05-27T21:42:26.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写文章前我决定先copy一份markdown的语法来，实在是忘了 = =！</p></blockquote><p>折腾了两天，总算是把博客弄好了，对于我这个懒人来说真是不容易，希望以后能抽空写写博客，毕竟生活中还是有不少事是值得记录的。</p><p>之前使用的博客是基于Jekyll+Gitment搭建的，用的主题是一个前端老哥写的H2O theme，可能有些人也知道吧，真的是很好看的主题，尤其是随着时间变换主题色这个功能我是太喜欢了，晚上看博文不刺眼了（明明没有人看）。但是奔着人活着就是为了折腾，这次我决定用Hexo+Valine来搭建新的博客（其实我就是看上了新主题）</p><p><strong>先附上之前博客的主题样式:</strong><br>白天：<br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280540044.png" alt="H2OThemeDay"><br>晚上：<br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280540644.png" alt="H2OThemeNight"> </p><p><strong>新的博客的样式：</strong><br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280541244.png" alt="JournalTheme">  </p><hr><p>还有一点也是推动我换框架的原因，之前用的Gitment在登录GitHub账号的时候总是会出问题，会弹出<code>[object XMLHttpRequestProgressEvent]</code>这样的错误，具体原因不是很明白。其次是咱国内的网络登录github的速度实在是一言难尽，我希望我的博客并不只服务于我们这些技术人，还有我一些生活上的朋友，让他们为了能给我留言评论还得大费周章的去注册个GitHub账号，实在是有些不妥。  </p><p>于是在朋友的推荐下，我决定使用一个特别好用的匿名评论插件Valine，Valine用的是一个叫LeanCloud的云数据库存储博客评论内容，因为我国法律的原因，所以我注册的是LeanCloud的国际版。</p><p>有了Hexo+Valine，博客基本的东西都OK了，于是我启动GitHub Pages服务，尝试访问。</p><p>正如我之前所说，国内的网络环境访问GitHub还是很慢的。这时候强迫症就上来了，我既然折腾到现在了，不如继续折腾下去吧，于是我打开阿里云准备开个全站加速，这东西我是第一次弄，之前完全没用到过，弄了半天才明白我还得买个域名。行嘛！我买还不行吗！于是买了个便宜的 <a href="">xuanxiaoming.info</a>，看起来还不错，哈哈。</p><blockquote><p>这里有个小插曲。因为是个人博客嘛，我本来是很想注册xuanxiaoming.me这个域名的，这个域名我当时只查到了在GoDaddy这个网站上购买，而这个网站的注册简直让我崩溃，它并不是及时注册成功的，差不多十几个小时后我才收到邮件说注册成功了，那个时候我所有的后续配置都已经做完还睡了一觉。。。</p></blockquote><p>后来我发现了一个网站<a href="https://www.domcomp.com/" target="_blank" rel="noopener">简化域名注册</a>，收罗了很多域名销售商，可以直接查出最便宜的购买点（包括了后续续费的价格），如果我再想买xuanxiaoming.me这个域名的话，我一定会去porkbun.com上购买。</p><p>扯得远了，域名买过后开始折腾起全站加速。懒得写大段文字了，直接看图吧，按红笔标的做就OK。</p><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280541043.jpeg" alt="全站加速配置"></p><p>全站加速配置完后列表页会给你一个CNAME值，将其填入域名解析的记录值中，保存，等一个TTL时间就好了。</p><p>开了全站加速后，我自己测试大概1~2秒就访问完成，确实快了很多。</p><p>最后我想再聊一聊感悟，这次博客搭建比我想象中要轻松一点，可能是因为踩过了Jekyll的坑，虽然有些不同，但简单看看就明白了，主要的时间都花费在博客功能配置和站点访问优化上了，所以现在赶紧记录下来既帮助自己又帮助别人。</p><blockquote><p>目前博客正在积极装修中，还有些旧的博文，我会慢慢搬运过来，期待一下以后的样子。<br>感谢你阅读到这！<br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280542960.jpg" alt="嘿嘿"></p></blockquote>]]></content>
    
    <summary type="html">
    
      趁博客搭好之际，赶紧记录下过程
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://xuanxiaoming.github.io/2020/01/12/markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://xuanxiaoming.github.io/2020/01/12/markdown-%E8%AF%AD%E6%B3%95/</id>
    <published>2020-01-12T08:17:20.000Z</published>
    <updated>2022-09-29T11:38:16.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1 标题"></a>1 标题</h1><p>两种形式：  </p><p>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><hr><h1 id="2-段落"><a href="#2-段落" class="headerlink" title="2 段落"></a>2 段落</h1><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><hr><h1 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3 区块引用"></a>3 区块引用</h1><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><hr><h1 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4 代码区块"></a>4 代码区块</h1><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><hr><h1 id="5-强调"><a href="#5-强调" class="headerlink" title="5 强调"></a>5 强调</h1><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><hr><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6 列表"></a>6 列表</h1><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><hr><h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7 分割线"></a>7 分割线</h1><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><hr><h1 id="8-链接"><a href="#8-链接" class="headerlink" title="8 链接"></a>8 链接</h1><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p><blockquote><p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><hr><h1 id="9-图片"><a href="#9-图片" class="headerlink" title="9 图片"></a>9 图片</h1><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。  </p><hr><h1 id="10-反斜杠"><a href="#10-反斜杠" class="headerlink" title="10 反斜杠\"></a>10 反斜杠<code>\</code></h1><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。  </p><hr><h1 id="11-符号’-’"><a href="#11-符号’-’" class="headerlink" title="11 符号’`’"></a>11 符号’`’</h1><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      copy来的语法知识，忘了就看看
    
    </summary>
    
    
    
      <category term="常用tips" scheme="https://xuanxiaoming.github.io/tags/%E5%B8%B8%E7%94%A8tips/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Generator配置解析</title>
    <link href="https://xuanxiaoming.github.io/2018/08/01/Mybatis%20Generator%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://xuanxiaoming.github.io/2018/08/01/Mybatis%20Generator%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2018-07-31T18:03:37.000Z</published>
    <updated>2022-05-27T21:48:48.726Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我想简单分析一下generatorConfig.xml这个配置文件的结构    </p><p>本篇文章参考 <a href="https://www.jianshu.com/p/e09d2370b796" target="_blank" rel="noopener">简书——叩丁狼教育</a> 和 <a href="https://www.cnblogs.com/GaiDynasty/p/4088531.html" target="_blank" rel="noopener">博客——改着名儿玩</a></p><p>我们先对这个配置文件做一个拆分，看看具体包含哪些东西（可以参考上一篇博客结尾代码）</p><pre><code>classPathEntry 加载类(比如jdbc驱动物理位置)  generatorConfiguration 配置器    - context 生成一组对象环境           -  jdbcConnection         数据库连接配置          -  javaModelGenerator     model (domain)配置          -  sqlMapGenerator        mapper配置          -  javaClientGenerator    dao配置          -  table                  表结构  </code></pre><p>根据上面的内容，就可以搭出来一个generatorConfig.xml的基本骨架了  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;  &lt;generatorConfiguration&gt;        &lt;classPathEntry  location=&quot;jdbc驱动位置&quot;/&gt;        &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;            &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                            connectionURL=&quot;jdbc:mysql://localhost:3306/数据库名&quot;                            userId=&quot;root&quot;                            password=&quot;root&quot;&gt;            &lt;/jdbcConnection&gt;            &lt;javaModelGenerator targetPackage=&quot;test.model&quot;                             targetProject=&quot;model生成的位置&quot;&gt;            &lt;/javaModelGenerator&gt;            &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;                             targetProject=&quot;mapper生成的位置&quot;&gt;            &lt;/sqlMapGenerator&gt;            &lt;javaClientGenerator type=&quot;ANNOTATEDMAPPER&quot;                             targetPackage=&quot;test.dao&quot;                             targetProject=&quot;dao层接口生成的位置&quot; /&gt;            &lt;table tableName=&quot;person&quot; &gt;                &lt;property name=&quot;id&quot; value=&quot;false&quot;/&gt;                &lt;!-- 其他字段 --&gt;            &lt;/table&gt;        &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>然后根据自己的需要再往里面添肉，一个适合你的generatorConfig.xml就完成了。  </p><p>比如我不想看它生成的注释，那我就加上  </p><pre><code>&lt;commentGenerator&gt;    &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;&lt;/commentGenerator&gt;</code></pre><p>要添肉的部分，叩丁狼教育的那篇简书里已经说的很详细了，这里就不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章我想简单分析一下generatorConfig.xml这个配置文件的结构    &lt;/p&gt;
&lt;p&gt;本篇文章参考 &lt;a href=&quot;https://www.jianshu.com/p/e09d2370b796&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://xuanxiaoming.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Gradle不支持MyBatis Generator怎么办</title>
    <link href="https://xuanxiaoming.github.io/2018/08/01/Gradle%E4%B8%8D%E6%94%AF%E6%8C%81MyBatis%20Generator%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://xuanxiaoming.github.io/2018/08/01/Gradle%E4%B8%8D%E6%94%AF%E6%8C%81MyBatis%20Generator%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2018-07-31T17:21:45.000Z</published>
    <updated>2022-05-27T21:59:02.055Z</updated>
    
    <content type="html"><![CDATA[<p>第一次用Gradle做Mybatis的项目，一上手就发现了一个问题 —— <em>哎？MyBatis Generator的插件怎么下不下来</em>  </p><p>然后就上官网查了一下，官网是这么说的： </p><blockquote><p>MyBatis Generator (MBG) can be run in the following ways:  </p><ul><li>From the command prompt with an XML configuration  </li><li>As an Ant task with an XML configuration  </li><li>As a Maven Plugin  </li><li>From another Java program with an XML configuration  </li><li>From another Java program with a Java based configuration  </li><li>As an Eclipse Feature  </li></ul></blockquote><p>这么看来MyBatis Generator是不支持Gradle的，而官网提供的解决方案除了第一条，我觉得都很麻烦，那么就用第一种方案解决问题吧！  </p><p>根据官网上的描述，我们总共需要准备三样东西：  </p><ul><li>mybatis-generator-core.jar</li><li>mysql-connector-java.jar</li><li>generatorConfig.xml</li></ul><p>有关generatorConfig.xml的描述，我放在了后面。  </p><p>准备工作做完后，将这三个文件放在同一文件夹下，执行 <code>java -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml</code>，就OK了，类似下图。<br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280558368.png" alt="图片">  </p><p>我这里给generatorConfig.xml起名叫test.xml，生成在test文件夹里了，起名字随意。<br><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280558536.png" alt="图片">  </p><p><img src="https://xxmblog-1256516391.cos.ap-nanjing.myqcloud.com/202205280558741.png" alt="图片">  </p><p>为了防止我说的不够详细，有遗漏的地方，官网描述也放<a href="http://www.mybatis.org/generator/running/runningFromCmdLine.html" target="_blank" rel="noopener">这里</a>  </p><p>最后，看一下generatorConfig.xml，这里为了让看博客的人看到这里能有个参考，我就直接把我自己写的test.xml贴出来了。想看更多的描述，稍后我会写一篇更详细的，不然东西都堆在这很乱。  </p><p>使用时请根据实际情况修改！</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry  location=&quot;mysql-connector-java-5.1.46.jar&quot;/&gt;      &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot; /&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot; /&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/test2?useSSL=false&quot;                        userId=&quot;root&quot;                        password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;C:\Users\MYPC\Desktop\123&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot; targetProject=&quot;C:\Users\MYPC\Desktop\123&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;                              targetPackage=&quot;test.dao&quot;                              targetProject=&quot;C:\Users\MYPC\Desktop\123&quot; /&gt;        &lt;table tableName=&quot;person&quot; &gt;            &lt;property name=&quot;id&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;name&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;sex&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;age&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;birthday&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;address&quot; value=&quot;false&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次用Gradle做Mybatis的项目，一上手就发现了一个问题 —— &lt;em&gt;哎？MyBatis Generator的插件怎么下不下来&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;然后就上官网查了一下，官网是这么说的： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyBatis Gene
      
    
    </summary>
    
    
    
      <category term="Gradle" scheme="https://xuanxiaoming.github.io/tags/gradle/"/>
    
      <category term="MyBatis" scheme="https://xuanxiaoming.github.io/tags/mybatis/"/>
    
  </entry>
  
</feed>
