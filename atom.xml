<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Almost&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuanxiaoming.github.io/"/>
  <updated>2022-05-05T04:17:47.662Z</updated>
  <id>https://xuanxiaoming.github.io/</id>
  
  <author>
    <name>Almost.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>playbook详解</title>
    <link href="https://xuanxiaoming.github.io/2022/01/18/playbook%E8%AF%A6%E8%A7%A3/"/>
    <id>https://xuanxiaoming.github.io/2022/01/18/playbook%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-18T04:51:18.000Z</published>
    <updated>2022-05-05T04:17:47.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Playbook详解"><a href="#Playbook详解" class="headerlink" title="Playbook详解"></a>Playbook详解</h1><p>playbook由一个或多个“plays”组成。它的内容是一个以“plays”为元素的列表。</p><p>在ansible中，play的内容被称为tasks（任务）。在基本层次的应用中，一个任务是一个对ansible模块的调用。</p><p>通过playbook，可以编排步骤进行多机器的部署，比如在webservers组的所有机器上运行一定的步骤，然后在database server组运行一些步骤，最后回到webservers组，再运行一些步骤，诸如此类。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 例如</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">vars</span><span class="token punctuation">:</span>    <span class="token key atrule">http_port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">max_clients</span><span class="token punctuation">:</span> <span class="token number">200</span>  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ensure apache is at the latest version    <span class="token key atrule">yum</span><span class="token punctuation">:</span> pkg=httpd state=latest  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> write the apache config file    <span class="token key atrule">template</span><span class="token punctuation">:</span> src=/srv/httpd.j2 dest=/etc/httpd.conf    <span class="token key atrule">notify</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> restart apache  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ensure apache is running    <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=started  <span class="token key atrule">handlers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart apache      <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=restarted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主机和用户"><a href="#主机和用户" class="headerlink" title="主机和用户"></a>主机和用户</h2><p>hosts行的内容是一个或多个组或主机的patterns，以逗号为分隔符；remote_user就是账户名（在Ansible 1.4以后才改为 remote_user。主要为了不跟user模块混淆，user 模块用于在远程系统上创建用户）</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 支持sudo执行命令</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> yourname  <span class="token key atrule">sudo</span><span class="token punctuation">:</span> yes<span class="token comment" spellcheck="true"># 也可以仅在一个task中使用sudo执行命令，而不是在整个play中使用sudo</span><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> yourname  <span class="token key atrule">tasks</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">service</span><span class="token punctuation">:</span> name=nginx state=started      <span class="token key atrule">sudo</span><span class="token punctuation">:</span> yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Tasks列表"><a href="#Tasks列表" class="headerlink" title="Tasks列表"></a>Tasks列表</h2><p>每一个play包含了一个task列表（任务列表）。一个task在其所对应的所有主机上执行完毕之后，下一个task才会执行。有一点需要明白的是，在一个play之中，所有hosts会获取相同的任务指令，这是play的一个目的所在，也就是会将所有选出的hosts映射上task。</p><p>每个task的目标在于执行一个moudle，通常是带有特定的参数来执行。在参数中可以使用变量（variables）。</p><p>modules具有“幂等”性，意思是如果你再一次地执行moudle，moudle只会执行必要的改动，只会改变需要改变的地方。所以重复多次执行playbook也很安全。</p><blockquote><p>为什么使用module而不是打包一套shell放在机器上运行？</p><p>答：为了幂等性，将tasks交给ansible控制，不至于多次执行tasks进行重复操作，从而降低风险。当然使用shell也有办法解决幂等性，但远不如这样更加直观。</p></blockquote><p>每一个task必须有一个名称name，这样在运行playbook时，从其输出的任务执行信息中可以很好的辨别出是属于哪一个task的。如果没有定义name，“action”的值将会用作输出信息中标记特定的task。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 基本的task的定义</span><span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> make sure apache is running    <span class="token key atrule">service</span><span class="token punctuation">:</span> name=httpd state=running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较特别的两个modudle是command和shell，它们不使用key=value格式的参数，而是这样：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> disable selinux    <span class="token key atrule">command</span><span class="token punctuation">:</span> /sbin/setenforce 0<span class="token key atrule">tasks</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> run this command and ignore the result    <span class="token key atrule">shell</span><span class="token punctuation">:</span> /usr/bin/somecommand    <span class="token key atrule">ignore_errors</span><span class="token punctuation">:</span> <span class="token boolean important">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Action-Shorthand"><a href="#Action-Shorthand" class="headerlink" title="Action Shorthand"></a>Action Shorthand</h2><p>新版ansible更喜欢使用如下的格式列出modules：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">template</span><span class="token punctuation">:</span> src=templates/foo.j2 dest=/etc/foo.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Handlers-在发生改变时执行的操作"><a href="#Handlers-在发生改变时执行的操作" class="headerlink" title="Handlers: 在发生改变时执行的操作"></a>Handlers: 在发生改变时执行的操作</h2><p>module 具有”幂等”性,所以当远端系统被人改动时，可以重放playbooks达到恢复的目的。playbooks本身可以识别这种改动，并且有一个基本的event system（事件系统），可以响应这种改动。</p><p>（当发生改动时）‘notify’ actions会在playbook的每一个task结束时被触发，而且即使有多个不同的task通知改动的发生，‘notify’ actions只会被触发一次。</p><p>举例来说，比如多个resources指出因为一个配置文件被改动，所以apache需要重新启动，但是重新启动的操作只会被执行一次。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># ‘notify’ 下列出的即是handlers</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> template configuration file  <span class="token key atrule">template</span><span class="token punctuation">:</span> src=template.j2 dest=/etc/foo.conf  <span class="token key atrule">notify</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> restart memcached     <span class="token punctuation">-</span> restart apache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Handlers也是一些task的列表，通过名字来引用，它们和一般的task并没有什么区别。Handlers是由通知者进行notify, 如果没有被notify，handlers不会执行。不管有多少个通知者进行了notify，等到play中的所有task执行完成之后，handlers也只会被执行一次。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 这是一个handlers的示例:</span><span class="token key atrule">handlers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart memcached      <span class="token key atrule">service</span><span class="token punctuation">:</span>  name=memcached state=restarted    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> restart apache      <span class="token key atrule">service</span><span class="token punctuation">:</span> name=apache state=restarted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>handlers 最佳的应用场景是用来重启服务，或者触发系统重启操作。除此以外很少用到了。</p><p>handlers 会按照声明的顺序执行</p></blockquote><p>如果你想立即执行所有的handler命令，在1.2及以后的版本，你可以这样做:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 任何在排队等候的handlers会在执行到‘meta’部分时，优先执行</span><span class="token key atrule">tasks</span><span class="token punctuation">:</span>   <span class="token punctuation">-</span> <span class="token key atrule">shell</span><span class="token punctuation">:</span> some tasks go here   <span class="token punctuation">-</span> <span class="token key atrule">meta</span><span class="token punctuation">:</span> flush_handlers   <span class="token punctuation">-</span> <span class="token key atrule">shell</span><span class="token punctuation">:</span> some other tasks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行Playbook"><a href="#执行Playbook" class="headerlink" title="执行Playbook"></a>执行Playbook</h2><pre class="line-numbers language-shell"><code class="language-shell"># 运行10个并发的playbook> ansible-playbook playbook.yml -f 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Playbook基本结构"><a href="#Playbook基本结构" class="headerlink" title="Playbook基本结构"></a>Playbook基本结构</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># [···] 表示可选配置</span><span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span>vars<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span>  <span class="token key atrule">task</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>yum/template/service/<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token punctuation">[</span>notify<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>    service<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      有关Ansible playbook的详细解释的精简版，有助于理清思路
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Ansible笔记</title>
    <link href="https://xuanxiaoming.github.io/2022/01/14/ansible%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2022/01/14/ansible%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-13T18:01:32.000Z</published>
    <updated>2022-05-05T04:17:38.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible笔记"><a href="#Ansible笔记" class="headerlink" title="Ansible笔记"></a>Ansible笔记</h1><h3 id="ansible连接时是使用ssh还是open-ssh"><a href="#ansible连接时是使用ssh还是open-ssh" class="headerlink" title="ansible连接时是使用ssh还是open-ssh"></a>ansible连接时是使用ssh还是open-ssh</h3><p>很明显是使用ssh，open-ssh只是包装了ssh的一个插件，本质上还是使用ssh</p><h3 id="inventory和ansible-cfg的有什么区别，作用是什么"><a href="#inventory和ansible-cfg的有什么区别，作用是什么" class="headerlink" title="inventory和ansible.cfg的有什么区别，作用是什么"></a>inventory和ansible.cfg的有什么区别，作用是什么</h3><p>inventory中文含义为库存，也叫物品清单。顾名思义是用于填写机器列表的地方，在文件 <code>/etc/ansible/host</code> 中根据语法填入接受控制机管理的机器ip即可</p><p>ansible.cfg为ansible的配置文件。配置文件可以修改很多东西，比如inventory文件指向、默认用户名密码等等，绝大多数情况下仅配置inventory就足够了</p><pre class="line-numbers language-shell"><code class="language-shell">> ansible --versionansible 2.9.6  config file = /etc/ansible/ansible.cfg  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']  ansible python module location = /usr/lib/python3/dist-packages/ansible  executable location = /usr/bin/ansible  python version = 3.8.10 (default, Nov 26 2021, 20:14:08) [GCC 9.3.0]> cat /etc/ansible/ansible.cfg | less[defaults]# some basic default values...#inventory      = /etc/ansible/hosts#library        = /usr/share/my_modules/#module_utils   = /usr/share/my_module_utils/#remote_tmp     = ~/.ansible/tmp#local_tmp      = ~/.ansible/tmp#plugin_filters_cfg = /etc/ansible/plugin_filters.yml#forks          = 5#poll_interval  = 15#sudo_user      = root#ask_sudo_pass = True#ask_pass      = True#transport      = smart#remote_port    = 22#module_lang    = C#module_set_locale = False......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ssh配置提示-sshd-config-line-36-Deprecated-option-RSAAuthentication"><a href="#ssh配置提示-sshd-config-line-36-Deprecated-option-RSAAuthentication" class="headerlink" title="ssh配置提示 sshd_config line 36: Deprecated option RSAAuthentication"></a>ssh配置提示 sshd_config line 36: Deprecated option RSAAuthentication</h3><p>RSAAuthentication （rsa认证）是只支持第1代ssh通讯协议使用的配置项，在CentOS7.4中被废除了，而且前面提到过CentOS7开始预设使用第二代通讯协议，在CentOS7.4中没有找到指定协议版本的配置行，个人猜测是CentOS7.4全面抛弃第1代协议。</p><p>第2代ssh通讯协议的密钥验证选项是<code>#PubkeyAuthentication yes</code></p><p>这个选项默认是注释掉的，并且是默认开启的，因此我们在使用第二代ssh通讯协议时不需要再去纠结 RSAAuthentication 选项了，在CentOS7.4中其强行添加 RSAAuthentication 配置会触发系统对它的废除提示。</p><pre class="line-numbers language-log"><code class="language-log">reprocess config line 38: Deprecated option RSAAuthentication<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改ansible配置文件后，不需要重启"><a href="#修改ansible配置文件后，不需要重启" class="headerlink" title="修改ansible配置文件后，不需要重启"></a>修改ansible配置文件后，不需要重启</h3><p>ansible是一个可执行程序，不是服务。故修改任何参数都将在下一次运行中体现出来，不需要重启，也无方法重启。</p><h3 id="后续添加多台机器如何配置ansible"><a href="#后续添加多台机器如何配置ansible" class="headerlink" title="后续添加多台机器如何配置ansible"></a>后续添加多台机器如何配置ansible</h3><p>使用动态inventory</p>]]></content>
    
    <summary type="html">
    
      有关Ansible配置和使用中发生问题记录
    
    </summary>
    
    
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/12/13/docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/12/13/docker%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-13T07:34:51.000Z</published>
    <updated>2022-05-05T04:16:39.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker笔记"><a href="#Docker笔记" class="headerlink" title="Docker笔记"></a>Docker笔记</h1><h4 id="检索docker容器IP"><a href="#检索docker容器IP" class="headerlink" title="检索docker容器IP"></a>检索docker容器IP</h4><pre class="line-numbers language-shell"><code class="language-shell"># 为了回避前端vue页面渲染标记，请自行将 [[ 替换为 {{，反之同理docker inspect -f '[[range .NetworkSettings.Networks]][[.IPAddress]][[end]]' [CONTAINER ID]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="docker可视化管理容器"><a href="#docker可视化管理容器" class="headerlink" title="docker可视化管理容器"></a>docker可视化管理容器</h4><p>使用portainer-ce，ce通常是指官方维护的非商业版</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /Users/xuan/portainer_data:/data portainer/portainer-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="docker挂载卷的总结和避坑"><a href="#docker挂载卷的总结和避坑" class="headerlink" title="docker挂载卷的总结和避坑"></a>docker挂载卷的总结和避坑</h4><p>docker 有几种方式都可以挂载卷，实现与宿主机共享文件。但是我在网上搜索了很久也没有遇到讲解关于在dockerfile中使用volume实现docker run -v那种自定义挂载文件夹的方式，找了很长时间才找到问题所在。</p><p>正常使用挂载，假设我想将桌面的demo文件夹挂载到ubuntu中的share文件夹，我可以这么写<code>docker run -v /Desktop/demo:/share ubuntu</code>。但是这样在dockerfile中是不允许的，dockerfile文件的目的是为了编撰镜像属性，而不是交互属性。交互属性应该是在镜像构建为容器时定义的。所以如果有交互方面的需求可以使用docker compose去实现。</p><p>实际上容器内部的文件夹有三种情况：</p><ol><li><p>没有指定VOLUME，也没有指定-v，这种是普通文件夹</p></li><li><p>指定了VOLUME，ENTRYPOINT没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改</p></li><li><p>指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改</p></li></ol><h4 id="dockerfile中-ENTRYPOINT-和-CMD-的区别"><a href="#dockerfile中-ENTRYPOINT-和-CMD-的区别" class="headerlink" title="dockerfile中 ENTRYPOINT 和 CMD 的区别"></a>dockerfile中 ENTRYPOINT 和 CMD 的区别</h4><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># dockerfile中写CMD echo "hello world"# 运行容器时docker run -it xxx /bin/bash# 会直接打开交互命令行，CMD内容被直接忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># dockerfile中写ENTRYPOINT echo "hello world"# 运行容器时docker run -it xxx /bin/bash# 会直接忽略/bin/bash，输出hello world# 只有在运行容器指令后加--entrypoint，才能覆盖dockerfile中的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常建议使用的方式是，CMD和ENTRYPOINT结合使用，并使用Exec格式编写，用CMD为ENTRYPOINT添加参数。</p>]]></content>
    
    <summary type="html">
    
      docker相关知识点和排坑记录
    
    </summary>
    
    
    
      <category term="docker" scheme="https://xuanxiaoming.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>linux三剑客</title>
    <link href="https://xuanxiaoming.github.io/2021/12/10/linux%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>https://xuanxiaoming.github.io/2021/12/10/linux%E4%B8%89%E5%89%91%E5%AE%A2/</id>
    <published>2021-12-10T07:29:38.000Z</published>
    <updated>2022-05-03T15:27:02.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>grep 命令用于查找文件里符合条件的字符串。</p><p>使用格式 <code>grep [command] &quot;待查文本&quot; &quot;查询地址（支持文件名通配符）&quot;</code></p><p>其中command可以使用 <code>-E</code> 使待查文本支持正则表达式</p><pre class="line-numbers language-shell"><code class="language-shell"># 例如：> grep test *file # 含义是在当前路径中所有文件名后缀为file的文件中查找‘test’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>-Eo</code> 可以只输出正则表达式匹配到的子字符串</p><p>比如在docker compose中启动多台容器，但我现在要获取除了主控制容器外的全部容器ip，我就可以这么写：</p><pre class="line-numbers language-shell"><code class="language-shell"># 为了回避前端vue页面渲染标记，请自行将 [[ 替换为 {{，反之同理docker network inspect -f "[[json .Containers]]" [网段docker network id] | jq '.[] | select(.Name != "xcontroller") | .IPv4Address' | grep -Eo '[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>使用了jq工具（需要额外安装 <code>apt install jq</code>）用于解析json</p></blockquote><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>sed命令用于对文件流进行编辑。意思就是说可以编辑文件，但编辑完不会保存到文件。</p><p>如果使用 <code>sed -i</code> 可以直接保存编辑文件内容。</p><p><code>$</code> 表示末尾，如想在末尾添加文本，可以 <code>sed -i &#39;$a [文本]&#39; [文件地址]</code> ，如果在 <code>a</code> 的前面不标明行号，则代表每行后都追加</p><p>行号写 <code>2,5</code> 不是第2行和第5行的意思，是2-5行</p><pre class="line-numbers language-shell"><code class="language-shell">sed '1i 添加的内容' file  #这是在第一行前添加字符串sed '$i 添加的内容' file  #这是在最后一行行前添加字符串sed '$a添加的内容' file   #这是在最后一行行后添加字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>]]></content>
    
    <summary type="html">
    
      关于linux上最常用的三个工具grep、sed、awk的笔记
    
    </summary>
    
    
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>m1芯片安装docker-mysql</title>
    <link href="https://xuanxiaoming.github.io/2021/11/15/m1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85docker-mysql/"/>
    <id>https://xuanxiaoming.github.io/2021/11/15/m1%E8%8A%AF%E7%89%87%E5%AE%89%E8%A3%85docker-mysql/</id>
    <published>2021-11-15T09:08:57.000Z</published>
    <updated>2022-05-05T04:17:34.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="m1芯片安装docker-mysql"><a href="#m1芯片安装docker-mysql" class="headerlink" title="m1芯片安装docker-mysql"></a>m1芯片安装docker-mysql</h2><p>自己平时是不喜欢直接在机器上安装mysql的，因为碎片文件比较多，删除mysql的时候会非常麻烦，得不厌其烦的寻找并删除碎片文件。直到我遇到了docker，我才觉得找到了答案，直接在docker上启动一个mysql服务，用可视化工具做远程连接就好，删除也没有负担，随时随地都可以重新准备就绪。</p><p>但是最近我在新电脑上启动docker-mysql时发现docker官方容器并不支持apple m1芯片，找了很长时间才找到一个由mysql官方维护的容器是支持的，于是就开始尝试使用这个容器。</p><p>在使用过程中，我发现一个问题就是我的DataGrid怎么也连不上mysql服务，一直提示 <code>[HY000][1130] null, message from server: &quot;Host &#39;172.17.0.1&#39; is not allowed to connect to this MySQL server&quot;.</code>。研究了很长时间，发现原因是该容器是mysql-server，可以理解为运行着mysql的服务器，所以本地连接的时候相当于远程访问，也就是说需要进容器内打开mysql的远程登录，并授予用户远程登录权限。</p><p>具体操作如下：</p><ol><li><p>启动mysql-server容器（可以加-v将宿主机卷空间挂载进去，用于备份数据库）</p><pre class="line-numbers language-shell"><code class="language-shell">docker run --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql/mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用改表法为用户增加访问权限docker exec进容器内，找到mysql库下的user表，将其hosts从localhost改成%或远程主机的IP（我这里是个人机器上使用就改root用户，具体请酌情考虑）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>prootmysql<span class="token operator">></span> <span class="token keyword">use</span> mysql<span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> host<span class="token punctuation">,</span><span class="token keyword">user</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">update</span> <span class="token keyword">user</span> <span class="token keyword">set</span> host<span class="token operator">=</span><span class="token string">"%"</span> <span class="token keyword">where</span> <span class="token keyword">user</span><span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">select</span> host<span class="token punctuation">,</span><span class="token keyword">user</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上述内容修改完后，就可以退出容器里，最后重启容器即可</p><pre class="line-numbers language-shell"><code class="language-shell">docker restart mysql-server;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>以上步骤都做完后，即可使用可视化工具远程访问mysql服务。最后需要注意的一点是，远程访问最好设置 <code>useSSL=true</code>，打开安全传输。</p>]]></content>
    
    <summary type="html">
    
      记录一下安装docker-mysql的过程
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://xuanxiaoming.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-02T01:35:47.000Z</published>
    <updated>2022-05-03T15:26:42.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库相关"><a href="#数据库相关" class="headerlink" title="数据库相关"></a>数据库相关</h1><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><h3 id="数据库事务的四个特性"><a href="#数据库事务的四个特性" class="headerlink" title="数据库事务的四个特性"></a>数据库事务的四个特性</h3><p>事务具有四个特性:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。这四个特性简称为ACID原则。</p><ol><li><p>原子性</p><p>事务必须是原子工作单元,事务中的操作要么全部执行,要么全都不执行,不能只完成部分操作。原子性在数据库系统中由恢复机制来实现。</p></li><li><p>一致性</p><p>事务开始之前,数据库处于一致性的状态;事务结束后,数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如,在银行转账中,用户可以定义转账前后两个账户金额之和保持不变。</p></li><li><p>隔离性</p><p>系统必须保证事务不受其他并发执行事务的影响,即当多个事务同时运行时,各事务之间相互隔离,不可互相干扰。事务查看数据时数据所处的状态,要么是另一个并发事务修改它之前的状态,要么是另一个并发事务修改它之后的状态,事务不会查看中间状态的数据。隔离性通过系统的并发控制机制实现。</p></li><li><p>持久性</p><p>一个已完成的事务对数据所做的任何变动在系统中是永久有效的,即使该事务产生的修改不正确,错误也将一直保持。持久性通过恢复机制实现,发生故障时,可以通过日志等手段恢复数据库信息。</p></li></ol><h3 id="数据库事务的作用"><a href="#数据库事务的作用" class="headerlink" title="数据库事务的作用"></a>数据库事务的作用</h3><p>当我们需要批量执行sql语句修改多条数据时，为了确保数据的一致性（比如张三给李四转账100元，张三的金额-100，李四金额+100），必须加入事务的使用用以在完整且正确执行完所有sql操作后，再提交对数据的修改。</p><p>假设当执行完第一条sql后突然断电引发操作异常，在没有执行commit之前，数据均不会修改。</p><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>主要有：<strong>表级锁</strong>和<strong>行级锁</strong></p><ol><li><p>读锁</p><p>可以并发读，但不可以并发写。读锁期间，没释放锁前不能进行写操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">table</span> <span class="token punctuation">[</span>TableName<span class="token punctuation">]</span> <span class="token keyword">read</span><span class="token punctuation">;</span>unlock <span class="token keyword">tables</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>写锁</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">table</span> <span class="token punctuation">[</span>TableName<span class="token punctuation">]</span> <span class="token keyword">write</span><span class="token punctuation">;</span>unlock <span class="token keyword">tables</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      数据相关知识
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://xuanxiaoming.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go学习笔记</title>
    <link href="https://xuanxiaoming.github.io/2021/09/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://xuanxiaoming.github.io/2021/09/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-01T01:38:14.000Z</published>
    <updated>2022-05-03T15:08:04.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Golang学习笔记"><a href="#Golang学习笔记" class="headerlink" title="Golang学习笔记"></a>Golang学习笔记</h2><h3 id="map清空的问题"><a href="#map清空的问题" class="headerlink" title="map清空的问题"></a>map清空的问题</h3><p>Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p><h3 id="并发安全的map"><a href="#并发安全的map" class="headerlink" title="并发安全的map"></a>并发安全的map</h3><p>Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p><p>sync.Map 有以下特性：</p><ul><li>无须初始化，直接声明即可。</li><li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li><li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li></ul><p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p><h3 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h3><ol><li>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据</li><li>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type</li><li>new 分配的空间被清零。make 分配空间后，会进行初始化</li></ol><p>make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p><h3 id="数组和切片的区别"><a href="#数组和切片的区别" class="headerlink" title="数组和切片的区别"></a>数组和切片的区别</h3><ul><li><p><strong>数组</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// value := [数据长度]类型 {}</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 声明并且赋值</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 声明未赋值</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>数组类型的值（以下简称数组）的长度是固定的数组的长度在声明它的时候就必须给定，并且在之后不会再改变。可以说，数组的长度是其类型的一部分（数组的容量永远等于其长度，都是不可变的）</p></li><li><p><strong>切片</strong></p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// value := []类型 {}</span><span class="token comment" spellcheck="true">// 创建长度容量都为0的切片</span>value <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// []string{"1"} 长度容量为1的切片</span>value <span class="token operator">:=</span><span class="token function">append</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 数据转切片</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">}</span>slice <span class="token operator">:=</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 创建长度容量为1的切片</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 创建长度为1，容量为2的切片</span>slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片类型的值是可变长的。而切片的类型字面量中只有其元素的类型，而没有其长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减少。在每一个切片的底层数据结构中，会包含一个数组，可以被叫做底层数据，而切片就是对底层数组的引用，故而<strong>切片类型属于引用类型</strong>。</p></li></ul><blockquote><p>一个切片无法容纳更多的元素时，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。<br>但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。<br>只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。</p></blockquote><h3 id="import-导包前的下划线“-”含义"><a href="#import-导包前的下划线“-”含义" class="headerlink" title="import 导包前的下划线“_”含义"></a>import 导包前的下划线“_”含义</h3><p>import 下划线（如：import _ github/demo）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。</p><h3 id="sql-Open-中数据库连接串格式"><a href="#sql-Open-中数据库连接串格式" class="headerlink" title="sql.Open()中数据库连接串格式"></a>sql.Open()中数据库连接串格式</h3><p>sql.Open()中的数据库连接串格式为：<code>&quot;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&quot;</code></p><h3 id="Go-项目中是否应把-go-sum-放到-Git-版本库里？"><a href="#Go-项目中是否应把-go-sum-放到-Git-版本库里？" class="headerlink" title="Go 项目中是否应把 go.sum 放到 Git 版本库里？"></a>Go 项目中是否应把 go.sum 放到 Git 版本库里？</h3><p>官方的建议是要将 <code>go.sum</code> 和 <code>go.mod</code> 两个文件一起提交到代码库中，这样才能保证项目依赖包版本的一致，同时保证 Build 的一致性。</p><h3 id="Go语言无范型，如何创建多对象json？"><a href="#Go语言无范型，如何创建多对象json？" class="headerlink" title="Go语言无范型，如何创建多对象json？"></a>Go语言无范型，如何创建多对象json？</h3><p>go语言中struct创建的类型，可以做对象数组</p><p>例如有一个json长这样：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token property">"A"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"B"</span><span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        <span class="token property">"a"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"b"</span><span class="token operator">:</span> <span class="token number">2</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解析后直接使用[]User去接收</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ……<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里有一篇文章总结的很详细：<code>https://juejin.cn/post/6844903891344048141</code></p><h3 id="Go语言date类型，时间操作"><a href="#Go语言date类型，时间操作" class="headerlink" title="Go语言date类型，时间操作"></a>Go语言date类型，时间操作</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 获取当前时间</span>dateTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 年</span>year <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 月</span>month <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 日</span>day <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 小时</span>hour <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Hour</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 分钟</span>minute <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Minute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 秒</span>second <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 纳秒</span>nanosecond <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Nanosecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 时间戳，计算到秒</span>timeUnix <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳，计算到纳秒</span>timeUnixNano <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳格式化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 时间戳转为go格式的时间</span><span class="token keyword">var</span> timeUnix <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token number">1562555859</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Unix</span><span class="token punctuation">(</span>timeUnix<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 获取今天23:59:59秒的时间戳</span>currentTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>endTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">.</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> currentTime<span class="token punctuation">.</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           currentTime<span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> currentTime<span class="token punctuation">.</span><span class="token function">Location</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>endTime<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>endTime<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006/01/02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 计算两个时间戳相距多少时间，后面换算成各种单位</span>afterTime<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseDuration</span><span class="token punctuation">(</span><span class="token string">"1h"</span><span class="token punctuation">)</span>result <span class="token operator">:=</span> currentTime<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>afterTime<span class="token punctuation">)</span>beforeTime<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseDuration</span><span class="token punctuation">(</span><span class="token string">"-1h"</span><span class="token punctuation">)</span>result2 <span class="token operator">:=</span> currentTime<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>beforeTime<span class="token punctuation">)</span>m <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 分钟 \n"</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span><span class="token function">Minutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>h <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 小时 \n"</span><span class="token punctuation">,</span> h<span class="token punctuation">.</span><span class="token function">Hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>d <span class="token operator">:=</span> result<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v 天 \n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span><span class="token function">Hours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 判断一个时间相比另外一个时间过去了多久</span>startTime <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"离现在过去了："</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Go语言-空接口"><a href="#Go语言-空接口" class="headerlink" title="Go语言 空接口"></a>Go语言 空接口</h3><p>go语言中所有的类型都实现了空接口，相当于java中的Object，因此空接口可以存储任意类型的数值。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul><li>并行（parallelism）：指在同一时刻，有多条指令在多个处理器上同时执行。</li><li>并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速地轮换执行，得到在宏观上有多个进程同时执行的效果，但在微观上并不是同时执行，只是把时间片分成了若干段，使得多个进程快速交替执行。</li></ul><h3 id="什么是TPS，什么是QPS，区别是什么？"><a href="#什么是TPS，什么是QPS，区别是什么？" class="headerlink" title="什么是TPS，什么是QPS，区别是什么？"></a>什么是TPS，什么是QPS，区别是什么？</h3><ul><li>TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问（业务TPS = CAPS × 每个呼叫平均TPS）。TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。</li><li>QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</li></ul><h3 id="Go语言-CSP模型-channel-管道"><a href="#Go语言-CSP模型-channel-管道" class="headerlink" title="Go语言 CSP模型 channel(管道)"></a>Go语言 CSP模型 channel(管道)</h3><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做 <strong>通信顺序进程，是一种并发编程模型</strong> ，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p><p>Golang 就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有完全实现了CSP模型的所有理论，仅仅是借用了 process和channel这两个概念。process是在go语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。</p><p>Go语言的CSP模型是由协程Goroutine与通道Channel实现：</p><ul><li>Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。</li><li>通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。</li></ul><blockquote><p><strong>核心思想：不要通过共享内存来通信，而要通过通信来实现内存共享。</strong></p></blockquote><p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><h3 id="反射的意义，可以应用在什么地方？"><a href="#反射的意义，可以应用在什么地方？" class="headerlink" title="反射的意义，可以应用在什么地方？"></a>反射的意义，可以应用在什么地方？</h3><p>反射本质上不是一个编程语言必须具备的特性。<br>反射的意义在于将本应该对程序员透明的机制，暴露给程序员，使得我们有能力去操纵它，让它能够更灵活地完成我们的工作。<strong>即动态修补程序代码。</strong><br>反射这种东西，确实破坏了封装的初衷，但他们两者之间并不是绝对的对立。想一想，我们封装、隐藏细节、建立抽象屏障，无外乎都是为了降低程序的复杂度——这是工程上的折衷，因为面对复杂的程序结构，人脑太不够用了。在大量的实践中我们发现，我们抽象出来的通用模式并不是绝对的，很多问题在它构建的框架之下解决起来就是非常麻烦，所以需要反射这种机制，动态的、灵活的修补代码，使之为我们的实际业务需求建立服务。<br>所以有了反射这么一手，把很多难以预测的问题留到运行时，动态地去考虑去解决。这也就使得我们在走投无路时，还可以有一道后门开着让我们大摇大摆地进入。</p><h3 id="Go语言-函数名称前的变量含义"><a href="#Go语言-函数名称前的变量含义" class="headerlink" title="Go语言 函数名称前的变量含义"></a>Go语言 函数名称前的变量含义</h3><p>在接触到go之前，我认为函数和方法只是同一个东西的两个名字而已（在我熟悉的c/c++，python，java中没有明显的区别），但是在golang中者完全是两个不同的东西。官方的解释是，方法是包含了接收者的函数。golang语言中函数和方法是两种不同的概念</p><p>首先函数的格式是固定的，func ＋ 函数名 ＋ 参数 ＋ 返回值（可选） ＋ 函数体。</p><p>方法和函数的区别，方法在func关键字后是接收者而不是函数名，接收者可以是自己定义的一个类型，这个类型可以是struct，interface，甚至我们可以重定义基本数据类型。我们可以给他一些我们想要的方法来满足我们的实际工程中的需求，这里我们要注意一个细节，接收者是指针和非指针的区别，我们可以看到当接收者为指针式，我们可以通过方法改变该接收者的属性，但是非指针类型缺做不到。</p><p>假设将一个结构体看作是一个类，那么方法（有接收者的）可以看成是该类的成员函数</p><h3 id="反射三定律"><a href="#反射三定律" class="headerlink" title="反射三定律"></a>反射三定律</h3><ol><li>反射可以将接口类型变量转换为反射类型变量</li><li>反射可以将反射类型变量转换为接口类型</li><li>想要使用反射来修改变量的值，其值必须是可写的（CanSet）。这个值必须满足两个条件：<ul><li>变量可以被寻址（CanAddr）</li><li>变量可导出（结构体字段名首字母需大写，不能为匿名字段）</li></ul></li></ol><blockquote><p>反射的性能极差，能不用反射尽量不用</p></blockquote><h3 id="Go语言代码测试分类"><a href="#Go语言代码测试分类" class="headerlink" title="Go语言代码测试分类"></a>Go语言代码测试分类</h3><ul><li>单元测试<br>测试函数的功能性问题<br>使用方式：在函数名前加Test前缀，传入(t *testing.T)</li><li>基准测试<br>分析代码存在的CPU性能和内存分配问题<br>使用方法：在函数名前加Benchmark前缀，传入(t *testing.B)</li><li>覆盖率测试<br>统计通过运行程序包的测试有多少代码得到了执行<br>使用方法：go test -cover XX.go</li></ul><h3 id="Http、Socket、WebSocket之间联系与区别"><a href="#Http、Socket、WebSocket之间联系与区别" class="headerlink" title="Http、Socket、WebSocket之间联系与区别"></a>Http、Socket、WebSocket之间联系与区别</h3><p><strong>把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。</strong><br><strong>HTTP协议，有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。</strong><br><strong>WebSocket协议，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</strong></p><ul><li><p>Http协议：简单的对象访问协议，对应于应用层。Http协议是基于TCP链接的</p></li><li><p>tcp协议：对应于传输层</p></li><li><p>ip协议：对应与网络层</p><blockquote><p>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而Http是应用层协议，主要解决如何包装数据。<br>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p></blockquote></li><li><p>HTTP连接：http连接就是所谓的短连接，及客户端向服务器发送一次请求，服务器端相应后连接即会断掉。</p></li><li><p>Socket连接：socket连接及时所谓的长连接，理论上客户端和服务端一旦建立连接，则不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该链接已释放网络资源。所以当一个socket连接中没有数据的传输，那么为了位置连续的连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。</p></li></ul><h3 id="Go语言实现多态"><a href="#Go语言实现多态" class="headerlink" title="Go语言实现多态"></a>Go语言实现多态</h3><ol><li>创建公共接口</li><li>使用多个方法继承接口，传入参数为不同的结构体</li><li>调用时会根据传入参数的不同的结构体对象，分别调用不同的方法（实现多态）</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 公共接口</span><span class="token keyword">type</span> Mammal <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 不同的结构体对象</span><span class="token keyword">type</span> Dog <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Cat <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> Human <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d Dog<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"woof"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c Cat<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"meow"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>h Human<span class="token punctuation">)</span> <span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"speak"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 根据传入参数不同，调用不同的方法，实现多态</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> m Mammal    m <span class="token operator">=</span> Dog<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> Cat<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> Human<span class="token punctuation">{</span><span class="token punctuation">}</span>    m<span class="token punctuation">.</span><span class="token function">Say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3>]]></content>
    
    <summary type="html">
    
      go语言的学习笔记和问题思考
    
    </summary>
    
    
    
      <category term="golang" scheme="https://xuanxiaoming.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>使用picgo+jsDelivr提升博客图片载入速度</title>
    <link href="https://xuanxiaoming.github.io/2020/07/29/%E4%BD%BF%E7%94%A8picgo-jsdelivr%E6%8F%90%E5%8D%87%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%BD%BD%E5%85%A5%E9%80%9F%E5%BA%A6/"/>
    <id>https://xuanxiaoming.github.io/2020/07/29/%E4%BD%BF%E7%94%A8picgo-jsdelivr%E6%8F%90%E5%8D%87%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%BD%BD%E5%85%A5%E9%80%9F%E5%BA%A6/</id>
    <published>2020-07-29T15:20:41.000Z</published>
    <updated>2022-05-03T14:46:37.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很长时间没有来写博客了，最近一直在忙找工作和考研的事，有空也会刷些leetcode，每天生活都过于充实，疏忽了写博客。哎,慢慢补吧。</p></blockquote><p>我这个博客自建立以来就一直有个诟病，加载太慢，起初我以为是挂在github的原因，所以我开了全站加速，其实效果并不是那么好（当然我并不是说毫无影响，事实证明如果我把博客挂在码云上所有的问题都解决了）。排查了一些问题后，发现对加载速度影响最大的是图片的加载，所以我就一直在找解决办法，直到我无意中在知乎上看到了jsDelivr这个CDN。</p><p>我要做的事很简单，在写markdown的软件typora上配置picgo的使用，然后让图片上传到仓库中，获得到URL再改为jsDelivr的加载链接，最后直接替换原博客图片链接就可以了，接下来配上图再详细说一遍。</p><p>首先打开GitHub创建一个公共仓库存储图片，然后到个人设置的开发者设置那里生成一个token，这里的token只会出现一次，所以先复制保存下来。</p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200805152422.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200805152451.png" alt=""></p><p>然后到typora中配置picgo，当然也可以使用picgo-core，配置都比较简单这里就不赘述了，网上一搜一大堆。</p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200805153019.png" alt=""></p><p>把typora设置好后在到picgo里修改下图床设置，token项就是刚才复制保存的那个。存储路径就是将图片保存到仓库的指定路径下。</p><p>自定义域名这里需要注意一下，因为一会要修改成使用jsdelivr代理，所以填入<code>https://cdn.jsdelivr.net/gh/你的仓库名@master</code></p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200805153252.png" alt=""></p><p>为了方便使用和避免文件名重复，我还在picgo中开启了如下选项</p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200805154042.png" alt=""></p><p>在typora中上传完图片后，一般会直接替换掉图片的URL，如果是文章的头图之类的非markdown语法的图片链接，直接粘贴刚才自动复制的URL替换即可。</p><p>接下来就可以愉快的写博客了！！！</p><blockquote><p>经过我的实际测试使用jsDelivr代理后的图片的加载速度得到了飞速的提升，我这篇博客就加了很多图片，你们可以试试加载速度。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;很长时间没有来写博客了，最近一直在忙找工作和考研的事，有空也会刷些leetcode，每天生活都过于充实，疏忽了写博客。哎,慢慢补吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这个博客自建立以来就一直有个诟病，加载太慢，起初我以为是挂在githu
      
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密登录</title>
    <link href="https://xuanxiaoming.github.io/2020/07/10/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <id>https://xuanxiaoming.github.io/2020/07/10/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</id>
    <published>2020-07-10T04:19:26.000Z</published>
    <updated>2022-05-05T04:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h1><ol><li><p>在系统上安装ssh后，生成秘钥</p><pre class="line-numbers language-shell"><code class="language-shell">> ssh-keygen -t rsa -C "info"-t 指定加密算法-C 在密文尾部加标记信息 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>将公钥发布到待免密登录的机器上</p><pre class="line-numbers language-shell"><code class="language-shell">> cd ~/.ssh/# 有两种方式发送公钥到远程机器上 > ssh-copy-id -i [本地公钥文件id_rsa.pub路径] 用户名@IP# 这样一部就可以将公钥写到远程机器的 /.ssh/authorized_keys 中，缺点是默认22端口，不可更改> scp ~/.ssh/id_rsa.pub 用户名@IP:.ssh/id_rsa_remote.pub> cat id_rsa_remote.pub >> authorized_keys# 这种方式既可以设置端口，也可以用于对方机器非root用户的情况（需要密码）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell"># 在我们想使用脚本自动完成秘钥发布工作时，可以使用sshpass解决人机交互问题> sshpass -p '密码' ssh-copy-id "-o StrictHostKeyChecking=no" 用户名@IP# sshpass会为你的首次连接自动填充密码# 同时使用"-o StrictHostKeyChecking=no"解决输入密码后的网络校验工作，避免首次登录输入yes# 这样就解决了两步人机交互问题，实现自动化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：</p><ol><li><p>B机器上有A机器的公钥，则A可以免密登录到B，不要记反了。</p></li><li><p>可以使用 <code>passwd 用户名</code> 更改用户的密码</p></li><li><p>需要在sshd的配置文件 <code>/etc/ssh/sshd_config</code> 中增加 <code>PermitRootLogin yes</code> 和 <code>PubkeyAuthentication yes</code>，用于打开root用户远程访问和秘钥验证登录</p></li></ol></blockquote></li></ol><ol start="3"><li><p>ssh连接到到机器上</p><pre><code>配置完成后，使用 `ssh 用户名@IP` 连接远程机器，首次连接会询问是否继续，输入yes，会在本地生成known_hosts文件用于记录已访问机器</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      linux免密登录的配置方式
    
    </summary>
    
    
    
      <category term="linux" scheme="https://xuanxiaoming.github.io/tags/linux/"/>
    
      <category term="运维" scheme="https://xuanxiaoming.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建填坑记录 二</title>
    <link href="https://xuanxiaoming.github.io/2020/03/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BA%8C/"/>
    <id>https://xuanxiaoming.github.io/2020/03/04/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BA%8C/</id>
    <published>2020-03-04T11:26:52.000Z</published>
    <updated>2022-05-03T14:50:41.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在博客的维护和更新过程中我遇到了很多琐碎的小问题，我决定新建立一篇文章，用于记录这些小问题和解决办法。<br>由于内容过于琐碎，所以我就直接列表记录了，他们之间并无逻辑关联。 </p></blockquote><br> <blockquote><p><font style="font-size:120%"> <strong>修改首页左侧导航栏列表循序</strong>  </font></p></blockquote><p>我发现主题的创建者只将归档(archive)这个页面单独做了处理，而我新加入的页面直接是对<code>site.pages</code>这个变量做了一个遍历，这导致我无法控制列表的排布，显得很乱，所以我最终的解决方案是直接将中间这段代码注释掉，将<code>&lt;a&gt;</code>标签内容写了进去，很简单粗暴的解决办法。  </p><pre><code>&lt;% if (theme.archives) { %&gt;&lt;a class=&quot;a-block no-tint nav-link-item &lt;%= is_current(&#39;archives&#39;) &amp;&amp; &#39;active&#39; %&gt;&quot; href=&quot;&lt;%= config.root + &quot;archives&quot; %&gt;&quot;&gt;    &lt;%= __(&#39;Archive&#39;) %&gt;&lt;/a&gt;&lt;% } %&gt;&lt;% if(site.pages){ %&gt;&lt;% site.pages.each(function (page){ %&gt;&lt;a class=&quot;a-block nav-link-item &lt;%= is_current(page.path) &amp;&amp; &#39;active&#39; %&gt;&quot; href=&quot;&lt;%= config.root + page.path %&gt;&quot;&gt;    &lt;%= page.title %&gt;&lt;/a&gt;&lt;% });} %&gt;&lt;% if (theme.rss) { %&gt;&lt;a class=&quot;a-block no-tint nav-link-item&quot; href=&quot;&lt;%= config.root + theme.rss %&gt;&quot;&gt;    &lt;%= __(&#39;RSS&#39;) %&gt;&lt;/a&gt;&lt;% } %&gt;  </code></pre><p>之后我又发现PC网页上的导航顺序没问题了，但是移动端的页面列表循序还是乱的，在仔细核查了主题作者的代码后，我终于在另一个文件中找到了，为了方便以后修改，我在此记录一下。 </p><pre><code>side_nav.ejs —— PC端的导航模块single_column_head.ejs —— 移动端的导航模块  </code></pre><br><blockquote><p><font style="font-size:120%"> <strong>SSL证书申请，配置强制跳转https</strong> </font>  </p></blockquote><p>这块是这样的， 我上次在阿里云注册https的时候， 阿里云那边出了bug， 就是SSL证书那块我一直申请不下来（阿里云的免费SSL）， 点不动那个按钮， 所以就一直用http访问到现在， 这次我上阿里云的控制面板试探性的点了一下，发现这个可以申请了， 然后我就把https给配置好了。 为什么我一直要配置https呢，因为现在的浏览器，比如Safari、Chrome，他们都会把非https的连接标记为非安全连接，实际上你作为建站人你自己是知道的，就是一个博客而已什么也没干，但是这块就是让人很憋屈。  </p><p>配置完这个https之后，我平时访问的时候，我发现还是会有http的访问，起初我以为是浏览器缓存的问题，但是并不是这样，后来我改了很多东西，甚至怀疑到了CNAME这个文件上，现在想想真是可笑至极。最后这个问题我在阿里云的全站加速的配置里找到了。如图所示，修改下强制跳转就行。  </p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728181809.png" alt="强制跳转">  </p><br><blockquote><p><font style="font-size:120%"> <strong>CNAME文件与hexo忽略文件</strong> </font>  </p></blockquote><p>这个文件是做什么的，我就不说了，直接网上查一下就有。它在github中的作用是告诉gitHub page服务你的自定义域名是什么，顾名思义，这个文件里面填的就是你的域名，没别的了。</p><p>在和hexo连用的时候我发现一个问题，当我执行<code>hexo clean</code>命令后，会将public文件夹下的文件全部删除，包括CNAME。这时候有两种解决办法，一是将CNAME文件放到source文件夹下，这样在<code>hexo g</code>后会将该文件原封不动copy到public文件夹下，避免了clean的删除。二是在hexo的全局配置文件里加入忽略文件（hexo会默认忽略“.”开头的和隐藏的文件）</p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728181741.png" alt="hexoConfig">  </p><p>举例：  </p><pre><code># Include/Exclude Files/Foldersinclude:    - &quot;.nojekyll&quot;    # 包括 &#39;source/css/_typing.css&#39;    - &quot;css/_typing.css&quot;    # 包括 &#39;source/_css/&#39; 中的任何文件，但不包括子目录及其其中的文件。    - &quot;_css/*&quot;    # 包含 &#39;source/_css/&#39; 中的任何文件和子目录下的任何文件    - &quot;_css/**/*&quot;exclude:    # 不包括 &#39;source/js/test.js&#39;    - &quot;js/test.js&quot;    # 不包括 &#39;source/js/&#39; 中的文件、但包括子目录下的所有目录和文件    - &quot;js/*&quot;    # 不包括 &#39;source/js/&#39; 中的文件和子目录下的任何文件    - &quot;js/**/*&quot;    # 不包括 &#39;source/js/&#39; 目录下的所有文件名以 &#39;test&#39; 开头的文件，但包括其它文件和子目录下的单文件    - &quot;js/test*&quot;    # 不包括 &#39;source/js/&#39; 及其子目录中任何以 &#39;test&#39; 开头的文件    - &quot;js/**/test*&quot;    # 不要用 exclude 来忽略 &#39;source/_posts/&#39; 中的文件。你应该使用 &#39;skip_render&#39;，或者在要忽略的文件的文件名之前加一个下划线 &#39;_&#39;    # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。ignore:    # Ignore any folder named &#39;foo&#39;.    - &quot;**/foo&quot;    # Ignore &#39;foo&#39; folder in &#39;themes/&#39; only.    - &quot;**/themes/*/foo&quot;    # Same as above, but applies to every subfolders of &#39;themes/&#39;.    - &quot;**/themes/**/foo&quot;</code></pre><p> 我用的是第一种方法解决的，第二种方法我没试，不过官方文档里都写了，所以也是一种合格的解决办法。</p><br><blockquote><p><font style="font-size:120%"> <strong>创建标签页</strong> </font>  </p></blockquote><p>主题作者只写了按时间归档的页面，标签页并没有写，甚至在使用文档里也没有说明（这个说明文档非常的简陋，issue里面一片哀嚎），但是hexo是自己支持标签分类的，我们只需要稍加配置一下即可。</p><p><a href="https://github.com/SumiMakito/hexo-theme-Journal/issues/20#issuecomment-551090136" target="_blank" rel="noopener">参考这篇issue里面AmazingRise的回答</a>：  </p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728203823.png" alt="标签页配置">  </p><br><blockquote><p><font style="font-size:120%"> <strong>SEO优化</strong> </font>  </p></blockquote><p>参考这篇博文 –&gt; <a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a>  </p><p>说的很详细，我就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在博客的维护和更新过程中我遇到了很多琐碎的小问题，我决定新建立一篇文章，用于记录这些小问题和解决办法。&lt;br&gt;由于内容过于琐碎，所以我就直接列表记录了，他们之间并无逻辑关联。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt; 

&lt;blockquot
      
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建填坑记录</title>
    <link href="https://xuanxiaoming.github.io/2020/01/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://xuanxiaoming.github.io/2020/01/13/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-01-12T16:59:19.000Z</published>
    <updated>2022-05-04T15:34:51.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写文章前我决定先copy一份markdown的语法来，实在是忘了 = =！</p></blockquote><p>折腾了两天，总算是把博客弄好了，对于我这个懒人来说真是不容易，希望以后能抽空写写博客，毕竟生活中还是有不少事是值得记录的。</p><p>之前使用的博客是基于Jekyll+Gitment搭建的，用的主题是一个前端老哥写的H2O theme，可能有些人也知道吧，真的是很好看的主题，尤其是随着时间变换主题色这个功能我是太喜欢了，晚上看博文不刺眼了（明明没有人看）。但是奔着人活着就是为了折腾，这次我决定用Hexo+Valine来搭建新的博客（其实我就是看上了新主题）</p><p><strong>先附上之前博客的主题样式:</strong><br>白天：<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728204311.png" alt="H2OThemeDay"><br>晚上：<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728204326.png" alt="H2OThemeNight"> </p><p><strong>新的博客的样式：</strong><br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728204350.png" alt="JournalTheme">  </p><hr><p>还有一点也是推动我换框架的原因，之前用的Gitment在登录GitHub账号的时候总是会出问题，会弹出<code>[object XMLHttpRequestProgressEvent]</code>这样的错误，具体原因不是很明白。其次是咱国内的网络登录github的速度实在是一言难尽，我希望我的博客并不只服务于我们这些技术人，还有我一些生活上的朋友，让他们为了能给我留言评论还得大费周章的去注册个GitHub账号，实在是有些不妥。  </p><p>于是在朋友的推荐下，我决定使用一个特别好用的匿名评论插件Valine，Valine用的是一个叫LeanCloud的云数据库存储博客评论内容，因为我国法律的原因，所以我注册的是LeanCloud的国际版。</p><p>有了Hexo+Valine，博客基本的东西都OK了，于是我启动GitHub Pages服务，尝试访问。</p><p>正如我之前所说，国内的网络环境访问GitHub还是很慢的。这时候强迫症就上来了，我既然折腾到现在了，不如继续折腾下去吧，于是我打开阿里云准备开个全站加速，这东西我是第一次弄，之前完全没用到过，弄了半天才明白我还得买个域名。行嘛！我买还不行吗！于是买了个便宜的 <a href="">xuanxiaoming.info</a>，看起来还不错，哈哈。</p><blockquote><p>这里有个小插曲。因为是个人博客嘛，我本来是很想注册xuanxiaoming.me这个域名的，这个域名我当时只查到了在GoDaddy这个网站上购买，而这个网站的注册简直让我崩溃，它并不是及时注册成功的，差不多十几个小时后我才收到邮件说注册成功了，那个时候我所有的后续配置都已经做完还睡了一觉。。。</p></blockquote><p>后来我发现了一个网站<a href="https://www.domcomp.com/" target="_blank" rel="noopener">简化域名注册</a>，收罗了很多域名销售商，可以直接查出最便宜的购买点（包括了后续续费的价格），如果我再想买xuanxiaoming.me这个域名的话，我一定会去porkbun.com上购买。</p><p>扯得远了，域名买过后开始折腾起全站加速。懒得写大段文字了，直接看图吧，按红笔标的做就OK。</p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728204615.jpeg" alt="全站加速配置"></p><p>全站加速配置完后列表页会给你一个CNAME值，将其填入域名解析的记录值中，保存，等一个TTL时间就好了。</p><p>开了全站加速后，我自己测试大概1~2秒就访问完成，确实快了很多。</p><p>最后我想再聊一聊感悟，这次博客搭建比我想象中要轻松一点，可能是因为踩过了Jekyll的坑，虽然有些不同，但简单看看就明白了，主要的时间都花费在博客功能配置和站点访问优化上了，所以现在赶紧记录下来既帮助自己又帮助别人。</p><blockquote><p>目前博客正在积极装修中，还有些旧的博文，我会慢慢搬运过来，期待一下以后的样子。<br>感谢你阅读到这！<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728204631.jpg" alt="嘿嘿"></p></blockquote>]]></content>
    
    <summary type="html">
    
      趁博客搭好之际，赶紧记录下过程
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="https://xuanxiaoming.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://xuanxiaoming.github.io/2020/01/12/markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://xuanxiaoming.github.io/2020/01/12/markdown-%E8%AF%AD%E6%B3%95/</id>
    <published>2020-01-12T08:17:20.000Z</published>
    <updated>2022-04-27T13:44:01.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1 标题"></a>1 标题</h1><p>两种形式：  </p><p>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><hr><h1 id="2-段落"><a href="#2-段落" class="headerlink" title="2 段落"></a>2 段落</h1><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><hr><h1 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3 区块引用"></a>3 区块引用</h1><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><hr><h1 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4 代码区块"></a>4 代码区块</h1><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><hr><h1 id="5-强调"><a href="#5-强调" class="headerlink" title="5 强调"></a>5 强调</h1><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><hr><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6 列表"></a>6 列表</h1><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><hr><h1 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7 分割线"></a>7 分割线</h1><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><hr><h1 id="8-链接"><a href="#8-链接" class="headerlink" title="8 链接"></a>8 链接</h1><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p><blockquote><p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><hr><h1 id="9-图片"><a href="#9-图片" class="headerlink" title="9 图片"></a>9 图片</h1><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。  </p><hr><h1 id="10-反斜杠"><a href="#10-反斜杠" class="headerlink" title="10 反斜杠\"></a>10 反斜杠<code>\</code></h1><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。  </p><hr><h1 id="11-符号’-’"><a href="#11-符号’-’" class="headerlink" title="11 符号’`’"></a>11 符号’`’</h1><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      copy来的语法知识，忘了就看看
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis Generator配置解析</title>
    <link href="https://xuanxiaoming.github.io/2018/08/01/Mybatis%20Generator%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://xuanxiaoming.github.io/2018/08/01/Mybatis%20Generator%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2018-07-31T18:03:37.000Z</published>
    <updated>2022-04-27T13:44:01.694Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我想简单分析一下generatorConfig.xml这个配置文件的结构    </p><p>本篇文章参考 <a href="https://www.jianshu.com/p/e09d2370b796" target="_blank" rel="noopener">简书——叩丁狼教育</a> 和 <a href="https://www.cnblogs.com/GaiDynasty/p/4088531.html" target="_blank" rel="noopener">博客——改着名儿玩</a></p><p>我们先对这个配置文件做一个拆分，看看具体包含哪些东西（可以参考上一篇博客结尾代码）</p><pre><code>classPathEntry 加载类(比如jdbc驱动物理位置)  generatorConfiguration 配置器    - context 生成一组对象环境           -  jdbcConnection         数据库连接配置          -  javaModelGenerator     model (domain)配置          -  sqlMapGenerator        mapper配置          -  javaClientGenerator    dao配置          -  table                  表结构  </code></pre><p>根据上面的内容，就可以搭出来一个generatorConfig.xml的基本骨架了  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;  &lt;generatorConfiguration&gt;        &lt;classPathEntry  location=&quot;jdbc驱动位置&quot;/&gt;        &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;            &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                            connectionURL=&quot;jdbc:mysql://localhost:3306/数据库名&quot;                            userId=&quot;root&quot;                            password=&quot;root&quot;&gt;            &lt;/jdbcConnection&gt;            &lt;javaModelGenerator targetPackage=&quot;test.model&quot;                             targetProject=&quot;model生成的位置&quot;&gt;            &lt;/javaModelGenerator&gt;            &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot;                             targetProject=&quot;mapper生成的位置&quot;&gt;            &lt;/sqlMapGenerator&gt;            &lt;javaClientGenerator type=&quot;ANNOTATEDMAPPER&quot;                             targetPackage=&quot;test.dao&quot;                             targetProject=&quot;dao层接口生成的位置&quot; /&gt;            &lt;table tableName=&quot;person&quot; &gt;                &lt;property name=&quot;id&quot; value=&quot;false&quot;/&gt;                &lt;!-- 其他字段 --&gt;            &lt;/table&gt;        &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>然后根据自己的需要再往里面添肉，一个适合你的generatorConfig.xml就完成了。  </p><p>比如我不想看它生成的注释，那我就加上  </p><pre><code>&lt;commentGenerator&gt;    &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;    &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;&lt;/commentGenerator&gt;</code></pre><p>要添肉的部分，叩丁狼教育的那篇简书里已经说的很详细了，这里就不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章我想简单分析一下generatorConfig.xml这个配置文件的结构    &lt;/p&gt;
&lt;p&gt;本篇文章参考 &lt;a href=&quot;https://www.jianshu.com/p/e09d2370b796&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://xuanxiaoming.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Gradle不支持MyBatis Generator怎么办</title>
    <link href="https://xuanxiaoming.github.io/2018/08/01/Gradle%E4%B8%8D%E6%94%AF%E6%8C%81MyBatis%20Generator%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://xuanxiaoming.github.io/2018/08/01/Gradle%E4%B8%8D%E6%94%AF%E6%8C%81MyBatis%20Generator%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2018-07-31T17:21:45.000Z</published>
    <updated>2022-04-27T13:44:01.693Z</updated>
    
    <content type="html"><![CDATA[<p>第一次用Gradle做Mybatis的项目，一上手就发现了一个问题 —— <em>哎？MyBatis Generator的插件怎么下不下来</em>  </p><p>然后就上官网查了一下，官网是这么说的： </p><blockquote><p>MyBatis Generator (MBG) can be run in the following ways:  </p><ul><li>From the command prompt with an XML configuration  </li><li>As an Ant task with an XML configuration  </li><li>As a Maven Plugin  </li><li>From another Java program with an XML configuration  </li><li>From another Java program with a Java based configuration  </li><li>As an Eclipse Feature  </li></ul></blockquote><p>这么看来MyBatis Generator是不支持Gradle的，而官网提供的解决方案除了第一条，我觉得都很麻烦，那么就用第一种方案解决问题吧！  </p><p>根据官网上的描述，我们总共需要准备三样东西：  </p><ul><li>mybatis-generator-core.jar</li><li>mysql-connector-java.jar</li><li>generatorConfig.xml</li></ul><p>有关generatorConfig.xml的描述，我放在了后面。  </p><p>准备工作做完后，将这三个文件放在同一文件夹下，执行 <code>java -jar mybatis-generator-core-x.x.x.jar -configfile generatorConfig.xml</code>，就OK了，类似下图。<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205335.png" alt="图片">  </p><p>我这里给generatorConfig.xml起名叫test.xml，生成在test文件夹里了，起名字随意。<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205348.png" alt="图片">  </p><p><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205401.png" alt="图片">  </p><p>为了防止我说的不够详细，有遗漏的地方，官网描述也放<a href="http://www.mybatis.org/generator/running/runningFromCmdLine.html" target="_blank" rel="noopener">这里</a>  </p><p>最后，看一下generatorConfig.xml，这里为了让看博客的人看到这里能有个参考，我就直接把我自己写的test.xml贴出来了。想看更多的描述，稍后我会写一篇更详细的，不然东西都堆在这很乱。  </p><p>使用时请根据实际情况修改！</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry  location=&quot;mysql-connector-java-5.1.46.jar&quot;/&gt;      &lt;context id=&quot;MysqlContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot; /&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot; /&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/test2?useSSL=false&quot;                        userId=&quot;root&quot;                        password=&quot;root&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;javaModelGenerator targetPackage=&quot;test.model&quot; targetProject=&quot;C:\Users\MYPC\Desktop\123&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;test.xml&quot; targetProject=&quot;C:\Users\MYPC\Desktop\123&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;                              targetPackage=&quot;test.dao&quot;                              targetProject=&quot;C:\Users\MYPC\Desktop\123&quot; /&gt;        &lt;table tableName=&quot;person&quot; &gt;            &lt;property name=&quot;id&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;name&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;sex&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;age&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;birthday&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;address&quot; value=&quot;false&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次用Gradle做Mybatis的项目，一上手就发现了一个问题 —— &lt;em&gt;哎？MyBatis Generator的插件怎么下不下来&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;然后就上官网查了一下，官网是这么说的： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyBatis Gene
      
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://xuanxiaoming.github.io/tags/mybatis/"/>
    
      <category term="Gradle" scheme="https://xuanxiaoming.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>如何让Outlook (office365)不再弹出“没有默认的邮件客户端”对话框？</title>
    <link href="https://xuanxiaoming.github.io/2018/07/17/%E5%BC%B9%E5%87%BA%E9%BB%98%E8%AE%A4%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E8%AF%9D%E6%A1%86/"/>
    <id>https://xuanxiaoming.github.io/2018/07/17/%E5%BC%B9%E5%87%BA%E9%BB%98%E8%AE%A4%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E8%AF%9D%E6%A1%86/</id>
    <published>2018-07-17T08:12:33.000Z</published>
    <updated>2022-04-27T13:44:01.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇2018年我发布在知乎上的回答，这篇回答一直以来访问人数都很多且评论的人都给与一致的好评，所以我决定搬运到博客中来。</p></blockquote><p>我正好遇到这个问题，并且成功解决了，记下来帮助一下以后遇到问题的人。 </p><p>分析结果：</p><ul><li>触发这个弹窗的不是outlook程序，因为可能你和我一样已经把office 2016卸载了。 </li><li>也不是默认应用程序触发的弹窗。我把默认程序设置为邮件依旧弹窗。  </li><li>我在启动项里找到了office的lync，我不知道它从哪来的，但是也不是它，因为它没有运行。  </li><li>天知道我经历了什么…… 强迫症有时候真的会逼死人。  </li><li>最后当我看到service里的OneSyncSvc_sessionID服务项，答案就出来了。  </li></ul><div style="text-align: center"><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205555.jpg"></div><br>    <p>解决办法（服务里没法直接关闭）：</p><ol><li><p>定位注册表到“HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services”下。</p></li><li><p>找到4项 “OneSyncSvc”“OneSyncSvc_sessionID”“UserDataSvc”“UserDataSvc_sessionID”</p></li><li><p>把每项里“Start”的值设为4，重启就能看到效果了。（0 引导，1 系统，2 自动-默认，3 手动，4 禁用）</p></li></ol><br>  <blockquote><p>如果这篇文章有帮助你解决问题，治好强迫症，你可以来知乎里给我点赞。<br><a href="https://www.zhihu.com/question/40217178/answer/407644015" target="_blank" rel="noopener">如何让Outlook (office365)不再弹出“没有默认的邮件客户端”对话框？ - 拉格朗日的回答 - 知乎</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是一篇2018年我发布在知乎上的回答，这篇回答一直以来访问人数都很多且评论的人都给与一致的好评，所以我决定搬运到博客中来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我正好遇到这个问题，并且成功解决了，记下来帮助一下以后遇到问题的人。 &lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="windows" scheme="https://xuanxiaoming.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>为什么我墙裂建议大家使用枚举来实现单例</title>
    <link href="https://xuanxiaoming.github.io/2018/06/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%A2%99%E8%A3%82%E5%BB%BA%E8%AE%AE%E5%A4%A7%E5%AE%B6%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/"/>
    <id>https://xuanxiaoming.github.io/2018/06/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%A2%99%E8%A3%82%E5%BB%BA%E8%AE%AE%E5%A4%A7%E5%AE%B6%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/</id>
    <published>2018-06-15T07:27:14.000Z</published>
    <updated>2022-04-27T13:44:01.710Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，单例模式，一般有七种写法，那么这七种写法中，最好的是哪一种呢？为什么呢？本文就来抽丝剥茧一下。  </p><h3 id="哪种写单例的方式最好"><a href="#哪种写单例的方式最好" class="headerlink" title="哪种写单例的方式最好"></a>哪种写单例的方式最好</h3><p>在StakcOverflow中，有一个关于<a href="https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java" target="_blank" rel="noopener">What is an efficient way to implement a singleton pattern in Java?</a>的讨论：<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205909.png" alt="201806170342"><br>如上图，得票率最高的回答是：使用枚举。<br>回答者引用了Joshua Bloch大神在《Effective Java》中明确表达过的观点：</p><blockquote><p>使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。  </p></blockquote><p>如果你真的深入理解了单例的用法以及一些可能存在的坑的话，那么你也许也能得到相同的结论，那就是：使用枚举实现单例是一种很好的方法。  </p><h3 id="枚举单例写法简单"><a href="#枚举单例写法简单" class="headerlink" title="枚举单例写法简单"></a>枚举单例写法简单</h3><p>如果你看过<a href="http://www.hollischuang.com/archives/205" target="_blank" rel="noopener">《单例模式的七种写法》</a>中的实现单例的所有方式的代码，那就会发现，各种方式实现单例的代码都比较复杂。主要原因是在考虑线程安全问题。  </p><p>我们简单对比下“双重校验锁”方式和枚举方式实现单例的代码。  </p><p>“双重校验锁”实现单例：  </p><pre><code>public class Singleton {      private volatile static Singleton singleton;      private Singleton (){}      public static Singleton getSingleton() {      if (singleton == null) {          synchronized (Singleton.class) {          if (singleton == null) {              singleton = new Singleton();          }          }      }      return singleton;      }  }  </code></pre><p>枚举实现单例：  </p><pre><code>public enum Singleton {      INSTANCE;      public void whateverMethod() {      }  }  </code></pre><p>相比之下，你就会发现，枚举实现单例的代码会精简很多。  </p><p>上面的双重锁校验的代码之所以很臃肿，是因为大部分代码都是在保证线程安全。为了在保证线程安全和锁粒度之间做权衡，代码难免会写的复杂些。但是，这段代码还是有问题的，因为他无法解决反序列化会破坏单例的问题。  </p><h3 id="枚举可解决线程安全问题"><a href="#枚举可解决线程安全问题" class="headerlink" title="枚举可解决线程安全问题"></a>枚举可解决线程安全问题</h3><p>上面提到过。使用非枚举的方式实现单例，都要自己来保证线程安全，所以，这就导致其他方法必然是比较臃肿的。那么，为什么使用枚举就不需要解决线程安全问题呢？  </p><p>其实，并不是使用枚举就不需要保证线程安全，只不过线程安全的保证不需要我们关心而已。也就是说，其实在“底层”还是做了线程安全方面的保证的。  </p><p>那么，“底层”到底指的是什么？  </p><p>这就要说到关于枚举的实现了。这部分内容可以参考我的另外一篇博文<a href="http://www.hollischuang.com/archives/197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a>，这里我简单说明一下：  </p><p>定义枚举时使用<code>enum</code>和class一样，是Java中的一个关键字。就像class对应用一个Class类一样，<code>enum</code>也对应有一个<code>Enum</code>类。  </p><p>通过将定义好的枚举<a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">反编译</a>，我们就能发现，其实枚举在经过<code>javac</code>的编译之后，会被转换成形如<code>public final class T extends Enum</code>的定义。  </p><p>而且，枚举中的各个枚举项同事通过<code>static</code>来定义的。如：   </p><pre><code>public enum T {    SPRING,SUMMER,AUTUMN,WINTER;}    </code></pre><p>反编译后代码为：  </p><pre><code>public final class T extends Enum {    //省略部分内容    public static final T SPRING;    public static final T SUMMER;    public static final T AUTUMN;    public static final T WINTER;    private static final T ENUM$VALUES[];    static    {        SPRING = new T(&quot;SPRING&quot;, 0);        SUMMER = new T(&quot;SUMMER&quot;, 1);        AUTUMN = new T(&quot;AUTUMN&quot;, 2);        WINTER = new T(&quot;WINTER&quot;, 3);        ENUM$VALUES = (new T[] {            SPRING, SUMMER, AUTUMN, WINTER        });    }}  </code></pre><p>了解JVM的类加载机制的朋友应该对这部分比较清楚。<code>static</code>类型的属性会在类被加载之后被初始化，我们在<a href="http://www.hollischuang.com/archives/199" target="_blank" rel="noopener">深度分析Java的ClassLoader机制（源码级别）</a>和<a href="http://www.hollischuang.com/archives/201" target="_blank" rel="noopener">Java类的加载、链接和初始化</a>两个文章中分别介绍过，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用<code>ClassLoader</code>的<code>loadClass</code>方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个<code>enum</code>类型是线程安全的。  </p><p>也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。  </p><p>所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。  </p><h3 id="枚举可解决反序列化会破坏单例的问题"><a href="#枚举可解决反序列化会破坏单例的问题" class="headerlink" title="枚举可解决反序列化会破坏单例的问题"></a>枚举可解决反序列化会破坏单例的问题</h3><p>前面我们提到过，就是使用双重校验锁实现的单例其实是存在一定问题的，就是这种单例有可能被序列化锁破坏，关于这种破坏及解决办法，参看<a href="http://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">单例与序列化的那些事儿</a>，这里不做更加详细的说明了。</p><p>那么，对于序列化这件事情，为什么枚举又有先天的优势了呢？答案可以在<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serial-arch.html#6469" target="_blank" rel="noopener">Java Object Serialization Specification</a>中找到答案。其中专门对枚举的序列化做了如下规定：<br><img src="https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205847.png" alt="201806170400">   </p><p>大概意思就是：在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过<code>java.lang.Enum</code>的<code>valueOf</code>方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法。</p><p>普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。</p><p>但是，枚举的反序列化并不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。这部分内容在<a href="http://www.hollischuang.com/archives/197" target="_blank" rel="noopener">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a>中也有更加详细的介绍，还展示了部分代码，感兴趣的朋友可以前往阅读。   </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在所有的单例实现方式中，枚举是一种在代码写法上最简单的方式，之所以代码十分简洁，是因为Java给我们提供了<code>enum</code>关键字，我们便可以很方便的声明一个枚举类型，而不需要关心其初始化过程中的线程安全问题，因为枚举类在被虚拟机加载的时候会保证线程安全的被初始化。</p><p>除此之外，在序列化方面，Java中有明确规定，枚举的序列化和反序列化是有特殊定制的。这就可以避免反序列化过程中由于反射而导致的单例被破坏问题。  </p><p>(全文完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，单例模式，一般有七种写法，那么这七种写法中，最好的是哪一种呢？为什么呢？本文就来抽丝剥茧一下。  &lt;/p&gt;
&lt;h3 id=&quot;哪种写单例的方式最好&quot;&gt;&lt;a href=&quot;#哪种写单例的方式最好&quot; class=&quot;headerlink&quot; title=&quot;哪种写单例的方式最好
      
    
    </summary>
    
    
    
      <category term="转载" scheme="https://xuanxiaoming.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>关于canvas全屏的问题</title>
    <link href="https://xuanxiaoming.github.io/2016/12/11/%E5%85%B3%E4%BA%8Ecanvas%E5%85%A8%E5%B1%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xuanxiaoming.github.io/2016/12/11/%E5%85%B3%E4%BA%8Ecanvas%E5%85%A8%E5%B1%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2016-12-11T09:42:58.000Z</published>
    <updated>2022-04-27T13:44:01.711Z</updated>
    
    <content type="html"><![CDATA[<p>刚上手canvas，被它的全屏问题，搞到头疼，最后解决了，非常激动。</p><p>关于canvas全屏，实际上要知道两样东西。</p><ul><li>canvas等比缩放</li><li>canvas拉伸  </li></ul><br>  <h3 id="1-等比缩放"><a href="#1-等比缩放" class="headerlink" title="1 等比缩放"></a>1 等比缩放</h3><p>方法一：<code>&lt;canvas width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;</code></p><p>方法二：使用HTML5 Canvas API操作 </p><pre><code>var canvas = document.getElementById(&#39;canvas的id&#39;);canvas.width = 500;canvas.height= 500;</code></pre><p>以上方法设置宽高会以300*150的比例缩小扩大。<br><br></p><h3 id="2-拉伸"><a href="#2-拉伸" class="headerlink" title="2 拉伸"></a>2 拉伸</h3><p>若通过如下方法设置宽高，Canvas元素将由原来大小被拉伸到所设置的宽高。  </p><p>方法一：使用CSS 会被拉伸  </p><pre><code>#canvas的id｛    width:1000px;    height:1000px;｝</code></pre><p>方法二：使用HTML5 样式操作 会被拉伸  </p><pre><code>var canvas = document.getElementById(&#39;canvas的id&#39;);canvas.style.width = window.innerWidth + &quot;px&quot;;canvas.style.height = window.innerHeight + &quot;px&quot;;</code></pre><p>方法三 ：用jquery的<code>$(&quot;#id&quot;).width(500)</code>会被拉伸  </p><p>其它：canvas的width和height也不能用百分比表示。canvas会将百分值当成数值显示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚上手canvas，被它的全屏问题，搞到头疼，最后解决了，非常激动。&lt;/p&gt;
&lt;p&gt;关于canvas全屏，实际上要知道两样东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;canvas等比缩放&lt;/li&gt;
&lt;li&gt;canvas拉伸  &lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;  

&lt;h3 id=&quot;1
      
    
    </summary>
    
    
    
      <category term="前端" scheme="https://xuanxiaoming.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse启动错误：A Java Runtime Environment(JRE) or Java Development Kit(JDK) must be available……</title>
    <link href="https://xuanxiaoming.github.io/2016/10/30/eclipse%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/"/>
    <id>https://xuanxiaoming.github.io/2016/10/30/eclipse%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF/</id>
    <published>2016-10-30T08:10:11.000Z</published>
    <updated>2022-04-27T13:44:01.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇来自2016年我发布在CSDN博客上的博文，CSDN博客已经被我抛弃已久，本以为再无瓜葛，直到我前几天收到一份邮件说有新评论的内容，我才又去登录看了一下，发现这篇博文已被访问了近2万次，所以我决定将其搬运到我的新博客中。<br>已经很久没用Eclipse了，如果有人突然问我问题，我可能一时没法解决。</p></blockquote><pre><code>---------------------------Eclipse---------------------------A Java Runtime Environment (JRE) or Java Development Kit(JDK)must be available in order to run Eclipse. No Java virtualmachinewas found after searching the following locations:D:\eclipse\jre\bin\javaw.exejavaw.exe in your current PATH---------------------------确定   ---------------------------  </code></pre><p>解决这个问题前，先要明确自己的JAVA安装和环境变量配置没错。</p><p>我用的第一种解决办法是按照报错信息，手动填补出了一个D:\eclipse\jre\bin\javaw.exe（javaw.exe文件可以从jdk的bin目录下找到），Eclipse可以正常打开。</p><p>以上办法不是正规的解决办法，所以为了防止未知问题，我最后是拿第二种解决办法解决的。<br>打开Eclipse根目录eclipse.ini文件，在最前面加上两行：<br>-vm<br>C:\ProgramFiles\Java\jdk1.8.0_45\bin\javaw.exe（这个是你安装的javaw.exe的绝对路径）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是一篇来自2016年我发布在CSDN博客上的博文，CSDN博客已经被我抛弃已久，本以为再无瓜葛，直到我前几天收到一份邮件说有新评论的内容，我才又去登录看了一下，发现这篇博文已被访问了近2万次，所以我决定将其搬运到我的新博客中。&lt;br&gt;已经很久没用
      
    
    </summary>
    
    
    
      <category term="IDE" scheme="https://xuanxiaoming.github.io/tags/ide/"/>
    
  </entry>
  
</feed>
