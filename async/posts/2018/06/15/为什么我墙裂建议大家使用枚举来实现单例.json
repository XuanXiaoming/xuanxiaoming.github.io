{"tags":[{"name":"转载","permalink":"https://xuanxiaoming.github.io/tags/%E8%BD%AC%E8%BD%BD/","url":"/async/tags/转载.json","count":1}],"categories":[],"url":"/async/posts/2018/06/15/为什么我墙裂建议大家使用枚举来实现单例.json","date":1529047634000,"path":{"year":2018,"month":6,"day":15,"name":"为什么我墙裂建议大家使用枚举来实现单例"},"title":"为什么我墙裂建议大家使用枚举来实现单例","permalink":"https://xuanxiaoming.github.io/2018/06/15/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%A2%99%E8%A3%82%E5%BB%BA%E8%AE%AE%E5%A4%A7%E5%AE%B6%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B/","content":"<p>我们知道，单例模式，一般有七种写法，那么这七种写法中，最好的是哪一种呢？为什么呢？本文就来抽丝剥茧一下。  </p>\n<h3 id=\"哪种写单例的方式最好\"><a href=\"#哪种写单例的方式最好\" class=\"headerlink\" title=\"哪种写单例的方式最好\"></a>哪种写单例的方式最好</h3><p>在StakcOverflow中，有一个关于<a href=\"https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java\" target=\"_blank\" rel=\"noopener\">What is an efficient way to implement a singleton pattern in Java?</a>的讨论：<br><img src=\"https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205909.png\" alt=\"201806170342\"><br>如上图，得票率最高的回答是：使用枚举。<br>回答者引用了Joshua Bloch大神在《Effective Java》中明确表达过的观点：</p>\n<blockquote>\n<p>使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。  </p>\n</blockquote>\n<p>如果你真的深入理解了单例的用法以及一些可能存在的坑的话，那么你也许也能得到相同的结论，那就是：使用枚举实现单例是一种很好的方法。  </p>\n<h3 id=\"枚举单例写法简单\"><a href=\"#枚举单例写法简单\" class=\"headerlink\" title=\"枚举单例写法简单\"></a>枚举单例写法简单</h3><p>如果你看过<a href=\"http://www.hollischuang.com/archives/205\" target=\"_blank\" rel=\"noopener\">《单例模式的七种写法》</a>中的实现单例的所有方式的代码，那就会发现，各种方式实现单例的代码都比较复杂。主要原因是在考虑线程安全问题。  </p>\n<p>我们简单对比下“双重校验锁”方式和枚举方式实现单例的代码。  </p>\n<p>“双重校验锁”实现单例：  </p>\n<pre><code>public class Singleton {  \n    private volatile static Singleton singleton;  \n    private Singleton (){}  \n    public static Singleton getSingleton() {  \n    if (singleton == null) {  \n        synchronized (Singleton.class) {  \n        if (singleton == null) {  \n            singleton = new Singleton();  \n        }  \n        }  \n    }  \n    return singleton;  \n    }  \n}  </code></pre><p>枚举实现单例：  </p>\n<pre><code>public enum Singleton {  \n    INSTANCE;  \n    public void whateverMethod() {  \n    }  \n}  </code></pre><p>相比之下，你就会发现，枚举实现单例的代码会精简很多。  </p>\n<p>上面的双重锁校验的代码之所以很臃肿，是因为大部分代码都是在保证线程安全。为了在保证线程安全和锁粒度之间做权衡，代码难免会写的复杂些。但是，这段代码还是有问题的，因为他无法解决反序列化会破坏单例的问题。  </p>\n<h3 id=\"枚举可解决线程安全问题\"><a href=\"#枚举可解决线程安全问题\" class=\"headerlink\" title=\"枚举可解决线程安全问题\"></a>枚举可解决线程安全问题</h3><p>上面提到过。使用非枚举的方式实现单例，都要自己来保证线程安全，所以，这就导致其他方法必然是比较臃肿的。那么，为什么使用枚举就不需要解决线程安全问题呢？  </p>\n<p>其实，并不是使用枚举就不需要保证线程安全，只不过线程安全的保证不需要我们关心而已。也就是说，其实在“底层”还是做了线程安全方面的保证的。  </p>\n<p>那么，“底层”到底指的是什么？  </p>\n<p>这就要说到关于枚举的实现了。这部分内容可以参考我的另外一篇博文<a href=\"http://www.hollischuang.com/archives/197\" target=\"_blank\" rel=\"noopener\">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a>，这里我简单说明一下：  </p>\n<p>定义枚举时使用<code>enum</code>和class一样，是Java中的一个关键字。就像class对应用一个Class类一样，<code>enum</code>也对应有一个<code>Enum</code>类。  </p>\n<p>通过将定义好的枚举<a href=\"http://www.hollischuang.com/archives/58\" target=\"_blank\" rel=\"noopener\">反编译</a>，我们就能发现，其实枚举在经过<code>javac</code>的编译之后，会被转换成形如<code>public final class T extends Enum</code>的定义。  </p>\n<p>而且，枚举中的各个枚举项同事通过<code>static</code>来定义的。如：   </p>\n<pre><code>public enum T {\n    SPRING,SUMMER,AUTUMN,WINTER;\n}    </code></pre><p>反编译后代码为：  </p>\n<pre><code>public final class T extends Enum {\n    //省略部分内容\n    public static final T SPRING;\n    public static final T SUMMER;\n    public static final T AUTUMN;\n    public static final T WINTER;\n    private static final T ENUM$VALUES[];\n    static\n    {\n        SPRING = new T(&quot;SPRING&quot;, 0);\n        SUMMER = new T(&quot;SUMMER&quot;, 1);\n        AUTUMN = new T(&quot;AUTUMN&quot;, 2);\n        WINTER = new T(&quot;WINTER&quot;, 3);\n        ENUM$VALUES = (new T[] {\n            SPRING, SUMMER, AUTUMN, WINTER\n        });\n    }\n}  </code></pre><p>了解JVM的类加载机制的朋友应该对这部分比较清楚。<code>static</code>类型的属性会在类被加载之后被初始化，我们在<a href=\"http://www.hollischuang.com/archives/199\" target=\"_blank\" rel=\"noopener\">深度分析Java的ClassLoader机制（源码级别）</a>和<a href=\"http://www.hollischuang.com/archives/201\" target=\"_blank\" rel=\"noopener\">Java类的加载、链接和初始化</a>两个文章中分别介绍过，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用<code>ClassLoader</code>的<code>loadClass</code>方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个<code>enum</code>类型是线程安全的。  </p>\n<p>也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。  </p>\n<p>所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。  </p>\n<h3 id=\"枚举可解决反序列化会破坏单例的问题\"><a href=\"#枚举可解决反序列化会破坏单例的问题\" class=\"headerlink\" title=\"枚举可解决反序列化会破坏单例的问题\"></a>枚举可解决反序列化会破坏单例的问题</h3><p>前面我们提到过，就是使用双重校验锁实现的单例其实是存在一定问题的，就是这种单例有可能被序列化锁破坏，关于这种破坏及解决办法，参看<a href=\"http://www.hollischuang.com/archives/1144\" target=\"_blank\" rel=\"noopener\">单例与序列化的那些事儿</a>，这里不做更加详细的说明了。</p>\n<p>那么，对于序列化这件事情，为什么枚举又有先天的优势了呢？答案可以在<a href=\"https://docs.oracle.com/javase/7/docs/platform/serialization/spec/serial-arch.html#6469\" target=\"_blank\" rel=\"noopener\">Java Object Serialization Specification</a>中找到答案。其中专门对枚举的序列化做了如下规定：<br><img src=\"https://cdn.jsdelivr.net/gh/XuanXiaoming/picRepository@master/img/20200728205847.png\" alt=\"201806170400\">   </p>\n<p>大概意思就是：在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过<code>java.lang.Enum</code>的<code>valueOf</code>方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法。</p>\n<p>普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。</p>\n<p>但是，枚举的反序列化并不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。这部分内容在<a href=\"http://www.hollischuang.com/archives/197\" target=\"_blank\" rel=\"noopener\">深度分析Java的枚举类型—-枚举的线程安全性及序列化问题</a>中也有更加详细的介绍，还展示了部分代码，感兴趣的朋友可以前往阅读。   </p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在所有的单例实现方式中，枚举是一种在代码写法上最简单的方式，之所以代码十分简洁，是因为Java给我们提供了<code>enum</code>关键字，我们便可以很方便的声明一个枚举类型，而不需要关心其初始化过程中的线程安全问题，因为枚举类在被虚拟机加载的时候会保证线程安全的被初始化。</p>\n<p>除此之外，在序列化方面，Java中有明确规定，枚举的序列化和反序列化是有特殊定制的。这就可以避免反序列化过程中由于反射而导致的单例被破坏问题。  </p>\n<p>(全文完)</p>\n"}