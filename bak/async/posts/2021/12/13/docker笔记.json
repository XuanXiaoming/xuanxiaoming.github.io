{"tags":[{"name":"docker","permalink":"https://xuanxiaoming.github.io/tags/docker/","url":"/async/tags/docker.json","count":1}],"categories":[],"url":"/async/posts/2021/12/13/docker笔记.json","date":1639380891000,"path":{"year":2021,"month":12,"day":13,"name":"docker笔记"},"title":"Docker笔记","permalink":"https://xuanxiaoming.github.io/2021/12/13/docker%E7%AC%94%E8%AE%B0/","content":"<h1 id=\"Docker笔记\"><a href=\"#Docker笔记\" class=\"headerlink\" title=\"Docker笔记\"></a>Docker笔记</h1><h4 id=\"检索docker容器IP\"><a href=\"#检索docker容器IP\" class=\"headerlink\" title=\"检索docker容器IP\"></a>检索docker容器IP</h4><pre class=\"line-numbers language-shell\"><code class=\"language-shell\"># 为了回避前端vue页面渲染标记，请自行将 [[ 替换为 {{，反之同理\ndocker inspect -f '[[range .NetworkSettings.Networks]][[.IPAddress]][[end]]' [CONTAINER ID]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"docker可视化管理容器\"><a href=\"#docker可视化管理容器\" class=\"headerlink\" title=\"docker可视化管理容器\"></a>docker可视化管理容器</h4><p>使用portainer-ce，ce通常是指官方维护的非商业版</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /Users/xuan/portainer_data:/data portainer/portainer-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"docker挂载卷的总结和避坑\"><a href=\"#docker挂载卷的总结和避坑\" class=\"headerlink\" title=\"docker挂载卷的总结和避坑\"></a>docker挂载卷的总结和避坑</h4><p>docker 有几种方式都可以挂载卷，实现与宿主机共享文件。但是我在网上搜索了很久也没有遇到讲解关于在dockerfile中使用volume实现docker run -v那种自定义挂载文件夹的方式，找了很长时间才找到问题所在。</p>\n<p>正常使用挂载，假设我想将桌面的demo文件夹挂载到ubuntu中的share文件夹，我可以这么写<code>docker run -v /Desktop/demo:/share ubuntu</code>。但是这样在dockerfile中是不允许的，dockerfile文件的目的是为了编撰镜像属性，而不是交互属性。交互属性应该是在镜像构建为容器时定义的。所以如果有交互方面的需求可以使用docker compose去实现。</p>\n<p>实际上容器内部的文件夹有三种情况：</p>\n<ol>\n<li><p>没有指定VOLUME，也没有指定-v，这种是普通文件夹</p>\n</li>\n<li><p>指定了VOLUME，ENTRYPOINT没有指定-v，这种文件夹可以在不同容器之间共享，但是无法在本地修改</p>\n</li>\n<li><p>指定了-v的文件夹，这种文件夹可以在不同容器之间共享，且可以在本地修改</p>\n</li>\n</ol>\n<h4 id=\"dockerfile中-ENTRYPOINT-和-CMD-的区别\"><a href=\"#dockerfile中-ENTRYPOINT-和-CMD-的区别\" class=\"headerlink\" title=\"dockerfile中 ENTRYPOINT 和 CMD 的区别\"></a>dockerfile中 ENTRYPOINT 和 CMD 的区别</h4><pre class=\"line-numbers language-dockerfile\"><code class=\"language-dockerfile\"># dockerfile中写\nCMD echo \"hello world\"\n\n# 运行容器时\ndocker run -it xxx /bin/bash\n\n# 会直接打开交互命令行，CMD内容被直接忽略<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-dockerfile\"><code class=\"language-dockerfile\"># dockerfile中写\nENTRYPOINT echo \"hello world\"\n\n# 运行容器时\ndocker run -it xxx /bin/bash\n\n# 会直接忽略/bin/bash，输出hello world\n# 只有在运行容器指令后加--entrypoint，才能覆盖dockerfile中的定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通常建议使用的方式是，CMD和ENTRYPOINT结合使用，并使用Exec格式编写，用CMD为ENTRYPOINT添加参数。</p>\n"}